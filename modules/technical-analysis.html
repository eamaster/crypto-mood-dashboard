<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîç Technical Analysis Module - Crypto Dashboard</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üìà</text></svg>">
    <link rel="stylesheet" href="../style.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <!-- Removed problematic candlestick library - using custom implementation -->
</head>
<body>
    <header>
        <div class="header-content">
            <h1>üîç Technical Analysis Module</h1>
            <button id="themeToggle" class="theme-toggle">üåô</button>
        </div>
    </header>

    <main>
        <div class="ta-container">
            <div class="ta-header">
                <p class="subtitle">Professional crypto technical indicators and signals</p>
            </div>

        <div class="controls">
            <div class="control-group">
                <label for="coinSelect">Cryptocurrency:</label>
                <select id="coinSelect">
                    <option value="bitcoin">Bitcoin (BTC)</option>
                    <option value="ethereum">Ethereum (ETH)</option>
                    <option value="dogecoin">Dogecoin (DOGE)</option>
                    <option value="cardano">Cardano (ADA)</option>
                    <option value="solana">Solana (SOL)</option>
                    <option value="litecoin">Litecoin (LTC)</option>
                    <option value="bitcoin-cash">Bitcoin Cash (BCH)</option>
                    <option value="ripple">Ripple (XRP)</option>
                    <option value="polkadot">Polkadot (DOT)</option>
                    <option value="chainlink">Chainlink (LINK)</option>
                    <option value="stellar">Stellar (XLM)</option>
                    <option value="monero">Monero (XMR)</option>
                    <option value="tezos">Tezos (XTZ)</option>
                    <option value="eos">EOS (EOS)</option>
                    <option value="zcash">Zcash (ZEC)</option>
                    <option value="dash">Dash (DASH)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="timeframe">Timeframe:</label>
                <select id="timeframe">
                    <option value="7">7 Days</option>
                    <option value="14">14 Days</option>
                    <option value="30">30 Days</option>
                </select>
            </div>
            
            <div class="button-group">
                <button onclick="analyzeTA()">üîç Analyze</button>
                <button id="aiExplainBtn" onclick="getAIExplanation()" style="display: none;">ü§ñ AI Explain This</button>
                <button onclick="location.href='../index.html'" class="ta-button">üè† Back to Dashboard</button>
            </div>
        </div>

        <div class="ta-charts-grid">
            <div class="ta-chart-column left">
                <div class="ta-responsive-chart-container">
                    <h3>üìà Price Chart with Technical Indicators</h3>
                    <div class="chart-info-box">
                        <strong>‚ÑπÔ∏è Chart Information:</strong> Technical indicators (SMA, Bollinger Bands) start after collecting sufficient data points for accurate calculations. This delayed start is mathematically correct and ensures reliable signals.
                        <br><strong>ü§ñ AI Enhancement:</strong> Advanced AI analysis will automatically classify market mood and provide pattern explanations below the chart.
                    </div>
                    <div id="loading" class="loading" style="display: none;">Fetching data and calculating indicators...</div>
                    <div class="ta-responsive-chart-wrapper">
                        <canvas id="taChart"></canvas>
                    </div>
                    <div id="chartError" class="error" style="display: none;"></div>
                </div>

                <div class="ta-responsive-chart-container">
                    <h3>üìä Price Movement Analysis</h3>
                    <div class="chart-info-box">
                        <strong>‚ÑπÔ∏è Price Analysis Information:</strong> Shows price movements over time. Green bars = price increased from previous period, Red bars = price decreased, Blue line = overall trend.
                        <br><strong>üìä Visual Analysis:</strong> Bar heights represent actual price levels. Color patterns reveal market sentiment and momentum changes over the selected timeframe.
                        <br><strong>üîß Pattern Recognition:</strong> Consecutive price movements and trend changes help identify potential trading opportunities and market psychology.
                    </div>
                    <div id="candleLoading" class="loading" style="display: none;">Fetching OHLC data...</div>
                    <div class="ta-responsive-chart-wrapper">
                        <canvas id="candleChart"></canvas>
                    </div>
                    <div id="candleError" class="error" style="display: none;"></div>
                </div>
            </div>

            <div class="ta-chart-column right">
                <div class="indicators-panel">
                    <h3>üìä Technical Indicators</h3>
                    <div id="indicators">
                        <div class="loading">Analysis results will appear here...</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- AI-Powered Analysis Section -->
        <div id="aiAnalysisSection" style="display: none;">
            <div class="ai-analysis-card">
                <h3 class="ai-analysis-header">
                    ü§ñ AI-Powered Market Analysis
                    <span id="aiMethodBadge" class="ai-method-badge"></span>
                </h3>
                
                <div class="ai-analysis-grid">
                    <div class="ai-mood-display">
                        <div id="aiMoodIcon" class="ai-mood-icon">ü§ñ</div>
                        <div id="aiMoodLabel" class="ai-mood-label">Analyzing...</div>
                        <div id="aiConfidence" class="ai-confidence">Confidence: --</div>
                    </div>
                    
                    <div class="ai-reasoning-container">
                        <div id="aiReasoning" class="ai-reasoning">
                            Generating AI analysis...
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- AI Explanation Section -->
            <div id="aiExplanationSection" style="display: none;" class="ai-explanation-card">
                <h3 class="ai-explanation-header">
                    üß† AI Pattern Explanation
                    <span id="explainMethodBadge" class="ai-explain-badge"></span>
                </h3>
                <div id="aiExplanationContent" class="ai-explanation-content">
                    Click "AI Explain This" to get a detailed explanation of the current market pattern.
                </div>
            </div>
        </div>

        <div id="taSummary" style="display: none;"></div>
        </div>
    </main>

    <footer>
        <p>Data from Blockchair & <a href="https://newsapi.org/" target="_blank" rel="noopener">NewsAPI.org</a> ‚Ä¢ AI by Cohere ‚Ä¢ Built with Chart.js & Cloudflare Workers</p>
        <p><a href="../index.html">üè† Back to Dashboard</a> ‚Ä¢ <a href="index.html">üì¶ View all modules</a></p>
    </footer>

    <script>
        // Filter out browser extension errors from console
        const originalError = console.error;
        const originalWarn = console.warn;
        
        console.error = function(...args) {
            const message = args.join(' ');
            if (message.includes('runtime.lastError') || 
                message.includes('message port closed') || 
                message.includes('content script') ||
                message.includes('Receiving end does not exist') ||
                message.includes('message channel closed') ||
                message.includes('listener indicated an asynchronous response')) {
                return; // Ignore extension errors
            }
            originalError.apply(console, args);
        };
        
        // Also filter console warnings for extension-related issues
        console.warn = function(...args) {
            const message = args.join(' ');
            if (message.includes('runtime.lastError') || 
                message.includes('extension')) {
                return; // Ignore extension warnings
            }
            originalWarn.apply(console, args);
        };

        // Worker URL - Update this to your deployed worker
        const WORKER_URL = 'https://crypto-mood-dashboard.smah0085.workers.dev';
        
        let chartInstance = null;
        let candleChartInstance = null;
        
        // Backup function to force chart display if primary method fails
        function forceChartDisplay() {
            const canvas = document.getElementById('taChart');
            if (canvas && chartInstance) {
                console.log('üîß Forcing chart display as backup...');
                
                // Apply essential styles directly
                canvas.style.display = 'block';
                canvas.style.visibility = 'visible';
                canvas.style.opacity = '1';
                canvas.style.width = '100%';
                canvas.style.height = '420px';
                canvas.style.position = 'relative';
                canvas.style.zIndex = '10';
                canvas.classList.add('visible');
                
                // Force Chart.js to re-render
                chartInstance.update();
                chartInstance.resize();
                chartInstance.render();
                
                console.log('‚úÖ Backup chart display completed');
            }
        }

        // Technical Analysis Functions
        function calculateSMA(data, period) {
            const sma = [];
            for (let i = period - 1; i < data.length; i++) {
                const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b.y, 0);
                sma.push({
                    x: data[i].x,
                    y: sum / period
                });
            }
            return sma;
        }

        function calculateRSI(data, period = 14) {
            const changes = [];
            for (let i = 1; i < data.length; i++) {
                changes.push(data[i].y - data[i - 1].y);
            }

            let avgGain = 0;
            let avgLoss = 0;

            // Initial average
            for (let i = 0; i < period; i++) {
                if (changes[i] > 0) avgGain += changes[i];
                else avgLoss += Math.abs(changes[i]);
            }
            avgGain /= period;
            avgLoss /= period;

            const rsi = [];
            for (let i = period; i < changes.length; i++) {
                if (changes[i] > 0) {
                    avgGain = (avgGain * (period - 1) + changes[i]) / period;
                    avgLoss = (avgLoss * (period - 1)) / period;
                } else {
                    avgGain = (avgGain * (period - 1)) / period;
                    avgLoss = (avgLoss * (period - 1) + Math.abs(changes[i])) / period;
                }

                const rs = avgGain / avgLoss;
                const rsiValue = 100 - (100 / (1 + rs));
                rsi.push({
                    x: data[i + 1].x,
                    y: rsiValue
                });
            }
            return rsi;
        }

        function calculateBollingerBands(data, period = 20, stdDev = 2) {
            const sma = calculateSMA(data, period);
            const bands = { upper: [], middle: [], lower: [] };
            
            for (let i = 0; i < sma.length; i++) {
                const dataSlice = data.slice(i, i + period);
                const mean = sma[i].y;
                const variance = dataSlice.reduce((sum, point) => sum + Math.pow(point.y - mean, 2), 0) / period;
                const standardDeviation = Math.sqrt(variance);
                
                bands.middle.push(sma[i]);
                bands.upper.push({
                    x: sma[i].x,
                    y: mean + (standardDeviation * stdDev)
                });
                bands.lower.push({
                    x: sma[i].x,
                    y: mean - (standardDeviation * stdDev)
                });
            }
            
            return bands;
        }

        function generateTradingSignals(price, rsi, sma, bb) {
            const signals = [];
            const currentPrice = price[price.length - 1].y;
            
            // ‚úÖ FIX: Robust indicator value extraction with null checks
            const currentRSI = rsi.length > 0 ? rsi[rsi.length - 1].y : null;
            const currentSMA = sma.length > 0 ? sma[sma.length - 1].y : null;
            const currentBBUpper = bb.upper.length > 0 ? bb.upper[bb.upper.length - 1].y : null;
            const currentBBLower = bb.lower.length > 0 ? bb.lower[bb.lower.length - 1].y : null;

            // RSI Signals - only generate if RSI is available
            if (currentRSI !== null) {
                if (currentRSI < 30) {
                    signals.push({ type: 'RSI', signal: 'BUY', strength: 'Strong', reason: `Oversold condition (RSI ${currentRSI.toFixed(1)} < 30)` });
                } else if (currentRSI > 70) {
                    signals.push({ type: 'RSI', signal: 'SELL', strength: 'Strong', reason: `Overbought condition (RSI ${currentRSI.toFixed(1)} > 70)` });
                } else {
                    signals.push({ type: 'RSI', signal: 'NEUTRAL', strength: 'Weak', reason: `RSI ${currentRSI.toFixed(1)} in normal range (30-70)` });
                }
            } else {
                signals.push({ type: 'RSI', signal: 'NEUTRAL', strength: 'Weak', reason: 'RSI calculation pending (need 15+ data points)' });
            }

            // Moving Average Signals - only generate if SMA is available
            if (currentSMA !== null) {
                if (currentPrice > currentSMA * 1.02) {
                    signals.push({ type: 'SMA', signal: 'BUY', strength: 'Medium', reason: `Price $${currentPrice.toLocaleString()} above SMA $${currentSMA.toLocaleString()}` });
                } else if (currentPrice < currentSMA * 0.98) {
                    signals.push({ type: 'SMA', signal: 'SELL', strength: 'Medium', reason: `Price $${currentPrice.toLocaleString()} below SMA $${currentSMA.toLocaleString()}` });
                } else {
                    signals.push({ type: 'SMA', signal: 'NEUTRAL', strength: 'Weak', reason: `Price $${currentPrice.toLocaleString()} near SMA $${currentSMA.toLocaleString()}` });
                }
            } else {
                signals.push({ type: 'SMA', signal: 'NEUTRAL', strength: 'Weak', reason: 'SMA calculation pending (need 20+ data points)' });
            }

            // Bollinger Bands Signals - only generate if BB is available
            if (currentBBUpper !== null && currentBBLower !== null) {
                if (currentPrice < currentBBLower) {
                    signals.push({ type: 'BB', signal: 'BUY', strength: 'Medium', reason: `Price $${currentPrice.toLocaleString()} below lower band $${currentBBLower.toLocaleString()}` });
                } else if (currentPrice > currentBBUpper) {
                    signals.push({ type: 'BB', signal: 'SELL', strength: 'Medium', reason: `Price $${currentPrice.toLocaleString()} above upper band $${currentBBUpper.toLocaleString()}` });
                } else {
                    signals.push({ type: 'BB', signal: 'NEUTRAL', strength: 'Weak', reason: `Price $${currentPrice.toLocaleString()} within bands $${currentBBLower.toLocaleString()}-$${currentBBUpper.toLocaleString()}` });
                }
            } else {
                signals.push({ type: 'BB', signal: 'NEUTRAL', strength: 'Weak', reason: 'Bollinger Bands calculation pending (need 20+ data points)' });
            }

            return signals;
        }

        function analyzeCandlestickPatterns(ohlcData) {
            const patterns = [];
            
            if (ohlcData.length < 2) {
                console.log('üìä Insufficient data for pattern analysis');
                return patterns;
            }
            
            console.log(`üîç Analyzing patterns in ${ohlcData.length} OHLC periods...`);
            
            // Analyze all candles for patterns (not just last few)
            for (let i = 1; i < ohlcData.length; i++) {
                const candle = ohlcData[i];
                const prevCandle = ohlcData[i - 1];
                
                // Calculate candle properties
                const body = Math.abs(candle.c - candle.o);
                const upperShadow = candle.h - Math.max(candle.c, candle.o);
                const lowerShadow = Math.min(candle.c, candle.o) - candle.l;
                const totalRange = candle.h - candle.l;
                const isBullish = candle.c > candle.o;
                
                // More lenient thresholds for pattern detection
                const avgPrice = (candle.h + candle.l + candle.c + candle.o) / 4;
                const significantMove = avgPrice * 0.01; // 1% move is significant
                
                // 1. Doji pattern (small body relative to total range)
                if (totalRange > 0 && body < totalRange * 0.3 && totalRange > significantMove) {
                    patterns.push({
                        type: 'Doji',
                        signal: 'NEUTRAL',
                        strength: 'Medium',
                        reason: `Doji pattern shows market indecision (body: $${body.toFixed(2)}, range: $${totalRange.toFixed(2)})`,
                        timestamp: candle.x
                    });
                }
                
                // 2. Strong bullish/bearish candles
                if (body > totalRange * 0.6 && totalRange > significantMove) {
                    const patternType = isBullish ? 'Strong Bullish Candle' : 'Strong Bearish Candle';
                    const signal = isBullish ? 'BUY' : 'SELL';
                    patterns.push({
                        type: patternType,
                        signal: signal,
                        strength: 'Medium',
                        reason: `${patternType} with large body indicates strong ${isBullish ? 'buying' : 'selling'} pressure`,
                        timestamp: candle.x
                    });
                }
                
                // 3. Hammer-like patterns (longer lower shadow)
                if (totalRange > 0 && lowerShadow > body && lowerShadow > totalRange * 0.4) {
                    const patternName = 'Hammer-like';
                    patterns.push({
                        type: patternName,
                        signal: 'BUY',
                        strength: 'Medium',
                        reason: `${patternName} pattern with long lower shadow suggests potential support`,
                        timestamp: candle.x
                    });
                }
                
                // 4. Shooting Star-like patterns (longer upper shadow)
                if (totalRange > 0 && upperShadow > body && upperShadow > totalRange * 0.4) {
                    const patternName = 'Shooting Star-like';
                    patterns.push({
                        type: patternName,
                        signal: 'SELL',
                        strength: 'Medium',
                        reason: `${patternName} pattern with long upper shadow suggests potential resistance`,
                        timestamp: candle.x
                    });
                }
                
                // 5. Trend continuation patterns
                const prevBody = Math.abs(prevCandle.c - prevCandle.o);
                const prevIsBullish = prevCandle.c > prevCandle.o;
                
                // Two consecutive bullish candles
                if (isBullish && prevIsBullish && body > significantMove && prevBody > significantMove) {
                    patterns.push({
                        type: 'Bullish Continuation',
                        signal: 'BUY',
                        strength: 'Medium',
                        reason: 'Two consecutive bullish periods suggest upward momentum',
                        timestamp: candle.x
                    });
                }
                
                // Two consecutive bearish candles
                if (!isBullish && !prevIsBullish && body > significantMove && prevBody > significantMove) {
                    patterns.push({
                        type: 'Bearish Continuation',
                        signal: 'SELL',
                        strength: 'Medium',
                        reason: 'Two consecutive bearish periods suggest downward momentum',
                        timestamp: candle.x
                    });
                }
                
                // 6. Reversal patterns (direction change)
                if (prevIsBullish && !isBullish && body > prevBody * 0.8) {
                    patterns.push({
                        type: 'Bearish Reversal',
                        signal: 'SELL',
                        strength: 'Strong',
                        reason: 'Strong bearish candle after bullish period suggests trend reversal',
                        timestamp: candle.x
                    });
                }
                
                if (!prevIsBullish && isBullish && body > prevBody * 0.8) {
                    patterns.push({
                        type: 'Bullish Reversal',
                        signal: 'BUY',
                        strength: 'Strong',
                        reason: 'Strong bullish candle after bearish period suggests trend reversal',
                        timestamp: candle.x
                    });
                }
            }
            
            console.log(`üîç Found ${patterns.length} candlestick patterns:`, patterns.map(p => p.type));
            return patterns;
        }

        function analyzePriceMovementPatterns(priceData) {
            const patterns = [];
            
            if (priceData.length < 3) {
                console.log('üìä Insufficient price data for pattern analysis');
                return patterns;
            }
            
            console.log(`üîç Analyzing price movement patterns in ${priceData.length} data points...`);
            
            // Calculate price movements and trends
            const movements = [];
            for (let i = 1; i < priceData.length; i++) {
                const prevPrice = priceData[i - 1].y;
                const currentPrice = priceData[i].y;
                const change = currentPrice - prevPrice;
                const percentChange = (change / prevPrice) * 100;
                
                movements.push({
                    x: priceData[i].x,
                    price: currentPrice,
                    change: change,
                    percentChange: percentChange,
                    isPositive: change >= 0,
                    isSignificant: Math.abs(percentChange) > 1 // 1% change is significant
                });
            }
            
            // Look for consecutive patterns
            for (let i = 1; i < movements.length; i++) {
                const currentMove = movements[i];
                const prevMove = movements[i - 1];
                
                // Strong upward movement
                if (currentMove.percentChange > 2) {
                    patterns.push({
                        type: 'Strong Price Increase',
                        signal: 'BUY',
                        strength: 'Medium',
                        reason: `Strong upward movement of ${currentMove.percentChange.toFixed(2)}% suggests buying interest`,
                        timestamp: currentMove.x
                    });
                }
                
                // Strong downward movement
                if (currentMove.percentChange < -2) {
                    patterns.push({
                        type: 'Strong Price Decrease',
                        signal: 'SELL',
                        strength: 'Medium',
                        reason: `Strong downward movement of ${currentMove.percentChange.toFixed(2)}% suggests selling pressure`,
                        timestamp: currentMove.x
                    });
                }
                
                // Trend continuation (two consecutive moves in same direction)
                if (currentMove.isPositive && prevMove.isPositive && 
                    currentMove.isSignificant && prevMove.isSignificant) {
                    patterns.push({
                        type: 'Bullish Momentum',
                        signal: 'BUY',
                        strength: 'Medium',
                        reason: 'Two consecutive positive price movements suggest upward momentum',
                        timestamp: currentMove.x
                    });
                }
                
                if (!currentMove.isPositive && !prevMove.isPositive && 
                    currentMove.isSignificant && prevMove.isSignificant) {
                    patterns.push({
                        type: 'Bearish Momentum',
                        signal: 'SELL',
                        strength: 'Medium',
                        reason: 'Two consecutive negative price movements suggest downward momentum',
                        timestamp: currentMove.x
                    });
                }
                
                // Reversal patterns (direction change)
                if (prevMove.isPositive && !currentMove.isPositive && 
                    Math.abs(currentMove.percentChange) > Math.abs(prevMove.percentChange)) {
                    patterns.push({
                        type: 'Bearish Reversal',
                        signal: 'SELL',
                        strength: 'Strong',
                        reason: 'Strong negative movement after positive suggests trend reversal',
                        timestamp: currentMove.x
                    });
                }
                
                if (!prevMove.isPositive && currentMove.isPositive && 
                    Math.abs(currentMove.percentChange) > Math.abs(prevMove.percentChange)) {
                    patterns.push({
                        type: 'Bullish Reversal',
                        signal: 'BUY',
                        strength: 'Strong',
                        reason: 'Strong positive movement after negative suggests trend reversal',
                        timestamp: currentMove.x
                    });
                }
            }
            
            // Look for consolidation patterns (small movements)
            let consolidationCount = 0;
            for (let i = movements.length - 5; i < movements.length; i++) {
                if (i >= 0 && Math.abs(movements[i].percentChange) < 0.5) {
                    consolidationCount++;
                }
            }
            
            if (consolidationCount >= 3) {
                patterns.push({
                    type: 'Price Consolidation',
                    signal: 'NEUTRAL',
                    strength: 'Medium',
                    reason: `Recent price movements show consolidation with ${consolidationCount} small changes`,
                    timestamp: movements[movements.length - 1].x
                });
            }
            
            // Look for overall trend in recent movements
            const recentMovements = movements.slice(-5);
            const positiveCount = recentMovements.filter(m => m.isPositive).length;
            const negativeCount = recentMovements.filter(m => !m.isPositive).length;
            
            if (positiveCount >= 4) {
                patterns.push({
                    type: 'Strong Uptrend',
                    signal: 'BUY',
                    strength: 'Strong',
                    reason: `${positiveCount} out of ${recentMovements.length} recent movements are positive`,
                    timestamp: movements[movements.length - 1].x
                });
            } else if (negativeCount >= 4) {
                patterns.push({
                    type: 'Strong Downtrend',
                    signal: 'SELL',
                    strength: 'Strong',
                    reason: `${negativeCount} out of ${recentMovements.length} recent movements are negative`,
                    timestamp: movements[movements.length - 1].x
                });
            }
            
            console.log(`üîç Found ${patterns.length} price movement patterns:`, patterns.map(p => p.type));
            return patterns;
        }

        function calculateOverallSignal(signals) {
            let buyCount = 0;
            let sellCount = 0;
            let totalStrength = 0;

            signals.forEach(signal => {
                const strengthValue = signal.strength === 'Strong' ? 3 : signal.strength === 'Medium' ? 2 : 1;
                totalStrength += strengthValue;

                if (signal.signal === 'BUY') buyCount += strengthValue;
                else if (signal.signal === 'SELL') sellCount += strengthValue;
            });

            const buyPercentage = (buyCount / totalStrength) * 100;
            const sellPercentage = (sellCount / totalStrength) * 100;
            const confidence = Math.max(buyPercentage, sellPercentage);

            if (buyPercentage > 60) return { signal: 'BUY', confidence: confidence.toFixed(1) };
            else if (sellPercentage > 60) return { signal: 'SELL', confidence: confidence.toFixed(1) };
            else return { signal: 'HOLD', confidence: (100 - confidence).toFixed(1) };
        }

        async function fetchPriceData(coinId, days) {
            try {
                console.log(`Fetching price data for ${coinId} over ${days} days...`);
                const response = await fetch(`${WORKER_URL}/history?coin=${coinId}&days=${days}`);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const data = await response.json();
                console.log(`Received ${data.prices.length} price points`);
                
                const priceData = data.prices.map(item => ({
                    x: new Date(item.timestamp),
                    y: item.price
                }));
                
                // Ensure we have enough data for technical analysis
                if (priceData.length < 20) {
                    throw new Error(`Insufficient data: only ${priceData.length} points available (need at least 20 for technical indicators)`);
                }
                
                return priceData;
            } catch (error) {
                console.error('Error fetching price data:', error);
                throw error;
            }
        }

        async function fetchOHLCData(coinId, days) {
            try {
                console.log(`Fetching OHLC data for ${coinId} over ${days} days...`);
                
                // First try to get OHLC data from a dedicated endpoint
                try {
                    const response = await fetch(`${WORKER_URL}/ohlc?coin=${coinId}&days=${days}`);
                    if (response.ok) {
                        const data = await response.json();
                        console.log(`Received ${data.ohlc.length} OHLC points`);
                        
                        const ohlcData = data.ohlc.map(item => ({
                            x: new Date(item.timestamp),
                            o: item.open,
                            h: item.high,
                            l: item.low,
                            c: item.close
                        }));
                        
                        return ohlcData;
                    }
                } catch (ohlcError) {
                    console.log('OHLC endpoint not available, using price data to simulate OHLC...');
                }
                
                // Fallback: Convert price data to simulated OHLC
                const priceData = await fetchPriceData(coinId, days);
                const ohlcData = [];
                
                // Create reasonable number of candlesticks (aim for 20-30 candles)
                const targetCandles = Math.min(30, Math.max(15, Math.floor(days * 0.8)));
                const periodSize = Math.max(1, Math.floor(priceData.length / targetCandles));
                
                console.log(`Creating ${targetCandles} target candles with period size ${periodSize} from ${priceData.length} price points`);
                
                for (let i = 0; i < priceData.length; i += periodSize) {
                    const periodData = priceData.slice(i, Math.min(i + periodSize, priceData.length));
                    if (periodData.length === 0) continue;
                    
                    const open = periodData[0].y;
                    const close = periodData[periodData.length - 1].y;
                    const high = Math.max(...periodData.map(p => p.y));
                    const low = Math.min(...periodData.map(p => p.y));
                    
                    // Ensure meaningful OHLC differences for pattern detection
                    const priceRange = high - low;
                    const bodySize = Math.abs(close - open);
                    
                    // Only include periods with meaningful price movement
                    if (priceRange > 0 && (bodySize > priceRange * 0.05 || priceRange > open * 0.001)) {
                        const candle = {
                            x: periodData[Math.floor(periodData.length / 2)].x, // Use middle timestamp
                            o: parseFloat(open.toFixed(2)),
                            h: parseFloat(high.toFixed(2)),
                            l: parseFloat(low.toFixed(2)),
                            c: parseFloat(close.toFixed(2)),
                            // Add volume simulation
                            v: Math.random() * 1000000 + 500000
                        };
                        ohlcData.push(candle);
                        
                        // Enhanced debug logging
                        if (ohlcData.length <= 5) {
                            console.log(`Candle ${ohlcData.length}:`, {
                                date: candle.x.toLocaleDateString(),
                                open: candle.o,
                                high: candle.h,
                                low: candle.l,
                                close: candle.c,
                                direction: candle.c >= candle.o ? 'BULLISH ‚¨ÜÔ∏è' : 'BEARISH ‚¨áÔ∏è',
                                bodySize: Math.abs(candle.c - candle.o).toFixed(2),
                                priceRange: priceRange.toFixed(2)
                            });
                        }
                    } else {
                        console.log(`Skipping period with insufficient movement: range=${priceRange.toFixed(2)}, body=${bodySize.toFixed(2)}`);
                    }
                }
                
                console.log(`Generated ${ohlcData.length} valid OHLC candles from price data`);
                return ohlcData;
                
            } catch (error) {
                console.error('Error fetching OHLC data:', error);
                throw error;
            }
        }

        function displayChart(price, sma20, bb) {
            console.log('Creating chart with data:', {
                pricePoints: price.length,
                smaPoints: sma20.length,
                bbUpperPoints: bb.upper.length,
                bbLowerPoints: bb.lower.length
            });
            
            const canvas = document.getElementById('taChart');
            const ctx = canvas.getContext('2d');
            
            // Reset canvas visibility
            canvas.style.display = 'none';
            canvas.classList.remove('visible');
            
            // ‚úÖ CHART FIX: Properly destroy existing chart to prevent memory leaks
            if (chartInstance) {
                // Unregister from responsive manager
                if (window.taChartManager) {
                    window.taChartManager.unregisterChart('taChart');
                }
                chartInstance.destroy();
                chartInstance = null;
            }

            // üõ†Ô∏è FIX: Enhanced theme-aware colors with better contrast
            const isDark = document.body.classList.contains('dark-theme');
            const priceColor = getComputedStyle(document.documentElement).getPropertyValue('--accent-color').trim() || '#3B82F6';
            const successColor = getComputedStyle(document.documentElement).getPropertyValue('--success-color').trim() || '#10B981';
            const dangerColor = getComputedStyle(document.documentElement).getPropertyValue('--danger-color').trim() || '#EF4444';
            const warningColor = getComputedStyle(document.documentElement).getPropertyValue('--warning-color').trim() || '#F59E0B';
            
            // üõ†Ô∏è FIX: Better contrast colors for both light and dark themes
            const textColor = isDark ? '#ffffff' : '#1a202c';
            const gridColor = isDark ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.1)';
            const backgroundColor = isDark ? 'rgba(30, 41, 59, 0.8)' : 'rgba(255, 255, 255, 0.95)';
            const borderColor = isDark ? 'rgba(255, 255, 255, 0.2)' : 'rgba(0, 0, 0, 0.1)';
            
            console.log('üé® Theme colors applied:', { isDark, textColor, gridColor, backgroundColor });

            // Prepare datasets for chart
            const datasets = [
                {
                    label: 'Price',
                    data: price,
                    borderColor: priceColor,
                    backgroundColor: priceColor + '20',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.1,
                    pointRadius: 1,
                    pointHoverRadius: 5,
                    order: 1
                }
            ];

            // Add SMA if available
            if (sma20.length > 0) {
                datasets.push({
                    label: `SMA 20 (${sma20.length} points)`,
                    data: sma20,
                    borderColor: successColor,
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    pointHoverRadius: 3,
                    order: 2
                });
            }

            // Add Bollinger Bands if available
            if (bb.upper.length > 0 && bb.lower.length > 0) {
                datasets.push(
                    {
                        label: `BB Upper (${bb.upper.length} points)`,
                        data: bb.upper,
                        borderColor: dangerColor,
                        borderWidth: 1,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0,
                        order: 3
                    },
                    {
                        label: `BB Lower (${bb.lower.length} points)`,
                        data: bb.lower,
                        borderColor: dangerColor,
                        borderWidth: 1,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0,
                        order: 4
                    }
                );
            }

            console.log('Chart datasets prepared:', datasets.map(d => ({ label: d.label, dataPoints: d.data.length })));

            // üõ†Ô∏è FIX: Enhanced Chart.js configuration with improved theme consistency
            chartInstance = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    resizeDelay: 100,
                    devicePixelRatio: window.devicePixelRatio || 1,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: { unit: 'day' },
                            ticks: {
                                maxTicksLimit: window.innerWidth < 768 ? 4 : 7,
                                font: {
                                    size: window.innerWidth < 768 ? 10 : 11,
                                    weight: '500',
                                    family: 'system-ui, -apple-system, sans-serif'
                                },
                                color: textColor,
                                padding: 2
                            },
                            grid: {
                                color: gridColor,
                                lineWidth: 1
                            },
                            border: {
                                color: borderColor,
                                width: 1
                            },
                            title: {
                                display: true,
                                text: 'Date',
                                color: textColor,
                                font: {
                                    size: window.innerWidth < 768 ? 11 : 12,
                                    weight: '600',
                                    family: 'system-ui, -apple-system, sans-serif'
                                },
                                padding: { top: 2, bottom: 2 }
                            }
                        },
                        y: {
                            beginAtZero: false,
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toLocaleString();
                                },
                                font: {
                                    size: window.innerWidth < 768 ? 10 : 11,
                                    weight: '500',
                                    family: 'system-ui, -apple-system, sans-serif'
                                },
                                color: textColor,
                                padding: 2
                            },
                            grid: {
                                color: gridColor,
                                lineWidth: 1
                            },
                            border: {
                                color: borderColor,
                                width: 1
                            },
                            title: {
                                display: true,
                                text: 'Price (USD)',
                                color: textColor,
                                font: {
                                    size: window.innerWidth < 768 ? 11 : 12,
                                    weight: '600',
                                    family: 'system-ui, -apple-system, sans-serif'
                                },
                                padding: { top: 2, bottom: 2 }
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'üìà Technical Analysis Chart',
                            font: { 
                                size: window.innerWidth < 768 ? 13 : 15,
                                weight: 'bold',
                                family: 'system-ui, -apple-system, sans-serif'
                            },
                            color: textColor,
                            padding: { top: 4, bottom: 6 }
                        },
                        legend: {
                            display: true,
                            position: window.innerWidth < 768 ? 'bottom' : 'top',
                            labels: {
                                font: {
                                    size: window.innerWidth < 768 ? 10 : 11,
                                    weight: '500',
                                    family: 'system-ui, -apple-system, sans-serif'
                                },
                                padding: 8,
                                usePointStyle: true,
                                boxWidth: window.innerWidth < 768 ? 8 : 10,
                                color: textColor
                            }
                        },
                        subtitle: {
                            display: window.innerWidth >= 768,
                            text: 'üìù Note: Technical indicators start after sufficient data points are collected for accurate calculation',
                            font: { 
                                size: 10,
                                style: 'italic',
                                weight: '400',
                                family: 'system-ui, -apple-system, sans-serif'
                            },
                            color: textColor,
                            padding: { top: 2, bottom: 6 }
                        },
                        tooltip: {
                            backgroundColor: backgroundColor,
                            titleColor: textColor,
                            bodyColor: textColor,
                            borderColor: borderColor,
                            borderWidth: 1,
                            cornerRadius: 6,
                            titleFont: { 
                                size: window.innerWidth < 768 ? 11 : 12,
                                weight: '600',
                                family: 'system-ui, -apple-system, sans-serif'
                            },
                            bodyFont: { 
                                size: window.innerWidth < 768 ? 10 : 11,
                                weight: '500',
                                family: 'system-ui, -apple-system, sans-serif'
                            },
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += '$' + context.parsed.y.toLocaleString();
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    layout: {
                        padding: { top: 2, bottom: 2, left: 2, right: 2 }
                    },
                    animation: {
                        duration: window.innerWidth < 768 ? 100 : 200,
                        easing: 'easeInOutQuart'
                    },
                    elements: {
                        point: {
                            radius: window.innerWidth < 768 ? 1 : 2,
                            hoverRadius: window.innerWidth < 768 ? 3 : 4,
                            borderWidth: window.innerWidth < 768 ? 1 : 1
                        },
                        line: {
                            tension: 0.1,
                            borderWidth: window.innerWidth < 768 ? 1 : 2
                        }
                    }
                }
            });

            // üîß FIXED: Reliable chart display with proper timing
            setTimeout(() => {
                const canvas = document.getElementById('taChart');
                
                // Simple, reliable canvas visibility
                canvas.style.display = 'block';
                canvas.style.visibility = 'visible';
                canvas.style.opacity = '1';
                canvas.classList.add('visible');
                
                // Ensure chart renders properly
                if (chartInstance) {
                    chartInstance.update();
                    chartInstance.resize();
                    
                    // Register chart with responsive manager
                    if (window.taChartManager) {
                        window.taChartManager.registerChart('taChart', chartInstance);
                    }
                    
                    // Final render after a short delay
                    setTimeout(() => {
                        chartInstance.render();
                        console.log('‚úÖ Chart successfully rendered:', {
                            canvasWidth: canvas.clientWidth,
                            canvasHeight: canvas.clientHeight,
                            hasChart: !!chartInstance,
                            datasetsCount: chartInstance.data.datasets.length
                        });
                    }, 50);
                }
            }, 100);
        }

                function displayCandlestickChart(ohlcData, coinId) {
            console.log('Creating OHLC visualization with data:', {
                candlePoints: ohlcData.length
            });
            
            // Validate OHLC data
            if (!ohlcData || ohlcData.length === 0) {
                console.error('No OHLC data available for candlestick chart');
                document.getElementById('candleError').style.display = 'block';
                document.getElementById('candleError').innerHTML = '<strong>‚ö†Ô∏è No Data:</strong> Unable to generate candlestick chart - insufficient price data.';
                return;
            }
            
            const canvas = document.getElementById('candleChart');
            const ctx = canvas.getContext('2d');
            
            // Reset canvas visibility
            canvas.style.display = 'none';
            canvas.classList.remove('visible');
            
            // Destroy existing chart to prevent memory leaks
            if (candleChartInstance) {
                // Unregister from responsive manager
                if (window.taChartManager) {
                    window.taChartManager.unregisterChart('candleChart');
                }
                candleChartInstance.destroy();
                candleChartInstance = null;
            }

            // Get theme-aware colors
            const isDark = document.body.classList.contains('dark-theme');
            const textColor = isDark ? '#ffffff' : '#1a202c';
            const gridColor = isDark ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.1)';
            const backgroundColor = isDark ? 'rgba(30, 41, 59, 0.8)' : 'rgba(255, 255, 255, 0.95)';
            const borderColor = isDark ? 'rgba(255, 255, 255, 0.2)' : 'rgba(0, 0, 0, 0.1)';
            
            console.log('üé® OHLC chart theme colors applied:', { isDark, textColor, gridColor, backgroundColor });

            // Create improved OHLC visualization using multiple datasets
            const datasets = [];
            
            // Split data into bullish and bearish periods
            const bullishCandles = ohlcData.filter(candle => candle.c > candle.o);
            const bearishCandles = ohlcData.filter(candle => candle.c < candle.o);
            const dojiCandles = ohlcData.filter(candle => Math.abs(candle.c - candle.o) < (candle.h - candle.l) * 0.1);
            
            console.log(`üìä OHLC Analysis: ${bullishCandles.length} bullish, ${bearishCandles.length} bearish, ${dojiCandles.length} doji periods`);
            
            // 1. Bullish periods (close > open) - Green bars
            if (bullishCandles.length > 0) {
                datasets.push({
                    label: `Bullish Periods (${bullishCandles.length})`,
                    type: 'bar',
                    data: bullishCandles.map(candle => ({
                        x: candle.x,
                        y: candle.c
                    })),
                    backgroundColor: '#10B98160',
                    borderColor: '#10B981',
                    borderWidth: 2,
                    barThickness: 'flex',
                    maxBarThickness: 20,
                    order: 1
                });
            }
            
            // 2. Bearish periods (close < open) - Red bars  
            if (bearishCandles.length > 0) {
                datasets.push({
                    label: `Bearish Periods (${bearishCandles.length})`,
                    type: 'bar', 
                    data: bearishCandles.map(candle => ({
                        x: candle.x,
                        y: candle.c
                    })),
                    backgroundColor: '#EF444460',
                    borderColor: '#EF4444',
                    borderWidth: 2,
                    barThickness: 'flex',
                    maxBarThickness: 20,
                    order: 2
                });
            }
            
            // 3. High-Low wicks for all periods
            datasets.push({
                label: 'High-Low Wicks',
                type: 'scatter',
                data: ohlcData.flatMap(candle => [
                    { x: candle.x, y: candle.h },
                    { x: candle.x, y: candle.l }
                ]),
                borderColor: '#6B728050',
                backgroundColor: '#6B728050',
                pointRadius: 1,
                pointHoverRadius: 3,
                showLine: false,
                order: 4
            });
            
            // 4. Overall price trend line
            datasets.push({
                label: 'Price Trend',
                type: 'line',
                data: ohlcData.map(candle => ({
                    x: candle.x,
                    y: candle.c
                })),
                borderColor: '#3B82F6',
                backgroundColor: 'transparent',
                borderWidth: 2,
                pointRadius: 1,
                pointHoverRadius: 4,
                tension: 0.2,
                order: 0
            });

            candleChartInstance = new Chart(ctx, {
                type: 'bar',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    resizeDelay: 0,
                    devicePixelRatio: window.devicePixelRatio || 1,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: { unit: 'day' },
                            ticks: {
                                maxTicksLimit: window.innerWidth < 768 ? 4 : 7,
                                font: {
                                    size: window.innerWidth < 768 ? 10 : 11,
                                    weight: '500',
                                    family: 'system-ui, -apple-system, sans-serif'
                                },
                                color: textColor,
                                padding: 2
                            },
                            grid: {
                                color: gridColor,
                                lineWidth: 1
                            },
                            border: {
                                color: borderColor,
                                width: 1
                            },
                            title: {
                                display: true,
                                text: 'Date',
                                color: textColor,
                                font: {
                                    size: window.innerWidth < 768 ? 11 : 12,
                                    weight: '600',
                                    family: 'system-ui, -apple-system, sans-serif'
                                },
                                padding: { top: 2, bottom: 2 }
                            }
                        },
                        y: {
                            beginAtZero: false,
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toLocaleString();
                                },
                                font: {
                                    size: window.innerWidth < 768 ? 10 : 11,
                                    weight: '500',
                                    family: 'system-ui, -apple-system, sans-serif'
                                },
                                color: textColor,
                                padding: 2
                            },
                            grid: {
                                color: gridColor,
                                lineWidth: 1
                            },
                            border: {
                                color: borderColor,
                                width: 1
                            },
                            title: {
                                display: true,
                                text: 'Price (USD)',
                                color: textColor,
                                font: {
                                    size: window.innerWidth < 768 ? 11 : 12,
                                    weight: '600',
                                    family: 'system-ui, -apple-system, sans-serif'
                                },
                                padding: { top: 2, bottom: 2 }
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'üïØÔ∏è OHLC Price Analysis',
                            font: { 
                                size: window.innerWidth < 768 ? 13 : 15,
                                weight: 'bold',
                                family: 'system-ui, -apple-system, sans-serif'
                            },
                            color: textColor,
                            padding: { top: 4, bottom: 6 }
                        },
                        legend: {
                            display: true,
                            position: window.innerWidth < 768 ? 'bottom' : 'top',
                            labels: {
                                font: {
                                    size: window.innerWidth < 768 ? 10 : 11,
                                    weight: '500',
                                    family: 'system-ui, -apple-system, sans-serif'
                                },
                                padding: 8,
                                usePointStyle: true,
                                boxWidth: window.innerWidth < 768 ? 8 : 10,
                                color: textColor,
                                filter: function(legendItem) {
                                    // Hide High-Low Wicks from legend to reduce clutter
                                    return !['High-Low Wicks'].includes(legendItem.text);
                                }
                            }
                        },
                        subtitle: {
                            display: window.innerWidth >= 768,
                            text: 'üìù Green bars = price increased, Red bars = price decreased, Blue line = price trend',
                            font: { 
                                size: 10,
                                style: 'italic',
                                weight: '400',
                                family: 'system-ui, -apple-system, sans-serif'
                            },
                            color: textColor,
                            padding: { top: 2, bottom: 6 }
                        },
                        tooltip: {
                            backgroundColor: backgroundColor,
                            titleColor: textColor,
                            bodyColor: textColor,
                            borderColor: borderColor,
                            borderWidth: 1,
                            cornerRadius: 6,
                            titleFont: { 
                                size: window.innerWidth < 768 ? 11 : 12,
                                weight: '600',
                                family: 'system-ui, -apple-system, sans-serif'
                            },
                            bodyFont: { 
                                size: window.innerWidth < 768 ? 10 : 11,
                                weight: '500',
                                family: 'system-ui, -apple-system, sans-serif'
                            },
                            callbacks: {
                                title: function(context) {
                                    return context[0].label; // Show the date
                                },
                                beforeBody: function(context) {
                                    // Find the corresponding OHLC data for this time point
                                    const timePoint = context[0].parsed.x;
                                    const candle = ohlcData.find(c => c.x.getTime() === new Date(timePoint).getTime());
                                    
                                    if (candle) {
                                        const priceChange = candle.c - candle.o;
                                        const percentChange = ((priceChange / candle.o) * 100).toFixed(2);
                                        const direction = candle.c >= candle.o ? 'üìà' : 'üìâ';
                                        
                                        return [
                                            `${direction} OHLC Data:`,
                                            `Open: $${candle.o.toLocaleString()}`,
                                            `High: $${candle.h.toLocaleString()}`,
                                            `Low: $${candle.l.toLocaleString()}`,
                                            `Close: $${candle.c.toLocaleString()}`,
                                            `Change: ${priceChange >= 0 ? '+' : ''}$${priceChange.toFixed(2)} (${percentChange}%)`,
                                            `Range: $${(candle.h - candle.l).toFixed(2)}`
                                        ];
                                    }
                                    return ['No OHLC data available'];
                                },
                                label: function(context) {
                                    // Show the dataset name and value
                                    const label = context.dataset.label || '';
                                    const value = context.parsed.y;
                                    return `${label}: $${value.toLocaleString()}`;
                                }
                            }
                        }
                    },
                    layout: {
                        padding: { top: 2, bottom: 2, left: 2, right: 2 }
                    },
                    animation: {
                        duration: window.innerWidth < 768 ? 100 : 200,
                        easing: 'easeInOutQuart'
                    }
                }
            });

            // Reliable chart display with proper timing
            setTimeout(() => {
                const canvas = document.getElementById('candleChart');
                
                // Simple, reliable canvas visibility
                canvas.style.display = 'block';
                canvas.style.visibility = 'visible';
                canvas.style.opacity = '1';
                canvas.classList.add('visible');
                
                // Ensure chart renders properly
                if (candleChartInstance) {
                    candleChartInstance.update();
                    candleChartInstance.resize();
                    
                    // Register chart with responsive manager
                    if (window.taChartManager) {
                        window.taChartManager.registerChart('candleChart', candleChartInstance);
                    }
                    
                    // Final render after a short delay
                    setTimeout(() => {
                        candleChartInstance.render();
                        console.log('‚úÖ OHLC chart successfully rendered:', {
                            canvasWidth: canvas.clientWidth,
                            canvasHeight: canvas.clientHeight,
                            hasChart: !!candleChartInstance,
                            totalCandles: ohlcData.length,
                            bullishCandles: bullishCandles.length,
                            bearishCandles: bearishCandles.length,
                            dojiCandles: dojiCandles.length,
                            datasetsCreated: datasets.length
                        });
                    }, 50);
                }
            }, 100);
        }

        function displayPriceBasedOHLC(priceData, coinId) {
            console.log('Creating price-based OHLC visualization with data:', {
                pricePoints: priceData.length
            });
            
            const canvas = document.getElementById('candleChart');
            const ctx = canvas.getContext('2d');
            
            // Reset canvas visibility
            canvas.style.display = 'none';
            canvas.classList.remove('visible');
            
            // Destroy existing chart to prevent memory leaks
            if (candleChartInstance) {
                // Unregister from responsive manager
                if (window.taChartManager) {
                    window.taChartManager.unregisterChart('candleChart');
                }
                candleChartInstance.destroy();
                candleChartInstance = null;
            }

            // Get theme-aware colors
            const isDark = document.body.classList.contains('dark-theme');
            const textColor = isDark ? '#ffffff' : '#1a202c';
            const gridColor = isDark ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.1)';
            const backgroundColor = isDark ? 'rgba(30, 41, 59, 0.8)' : 'rgba(255, 255, 255, 0.95)';
            const borderColor = isDark ? 'rgba(255, 255, 255, 0.2)' : 'rgba(0, 0, 0, 0.1)';
            
            // Create price movement visualization
            const datasets = [];
            
            // Calculate price changes between consecutive points
            const priceChanges = [];
            for (let i = 1; i < priceData.length; i++) {
                const prevPrice = priceData[i - 1].y;
                const currentPrice = priceData[i].y;
                const change = currentPrice - prevPrice;
                
                priceChanges.push({
                    x: priceData[i].x,
                    y: currentPrice,
                    change: change,
                    isPositive: change >= 0,
                    percentChange: (change / prevPrice) * 100
                });
            }
            
            // Split into positive and negative movements
            const positiveChanges = priceChanges.filter(p => p.isPositive);
            const negativeChanges = priceChanges.filter(p => !p.isPositive);
            
            console.log(`üìä Price Analysis: ${positiveChanges.length} positive movements, ${negativeChanges.length} negative movements`);
            
            // Positive price movements (green bars)
            if (positiveChanges.length > 0) {
                datasets.push({
                    label: `Price Increases (${positiveChanges.length})`,
                    type: 'bar',
                    data: positiveChanges.map(p => ({
                        x: p.x,
                        y: p.y
                    })),
                    backgroundColor: '#10B98160',
                    borderColor: '#10B981',
                    borderWidth: 2,
                    barThickness: 'flex',
                    maxBarThickness: 25,
                    order: 1
                });
            }
            
            // Negative price movements (red bars)
            if (negativeChanges.length > 0) {
                datasets.push({
                    label: `Price Decreases (${negativeChanges.length})`,
                    type: 'bar',
                    data: negativeChanges.map(p => ({
                        x: p.x,
                        y: p.y
                    })),
                    backgroundColor: '#EF444460',
                    borderColor: '#EF4444',
                    borderWidth: 2,
                    barThickness: 'flex',
                    maxBarThickness: 25,
                    order: 2
                });
            }
            
            // Overall price trend line
            datasets.push({
                label: 'Price Trend',
                type: 'line',
                data: priceData,
                borderColor: '#3B82F6',
                backgroundColor: 'transparent',
                borderWidth: 2,
                pointRadius: 2,
                pointHoverRadius: 5,
                tension: 0.2,
                order: 0
            });

            candleChartInstance = new Chart(ctx, {
                type: 'bar',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    resizeDelay: 0,
                    devicePixelRatio: window.devicePixelRatio || 1,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: { unit: 'day' },
                            ticks: {
                                maxTicksLimit: window.innerWidth < 768 ? 4 : 7,
                                font: {
                                    size: window.innerWidth < 768 ? 10 : 11,
                                    weight: '500',
                                    family: 'system-ui, -apple-system, sans-serif'
                                },
                                color: textColor,
                                padding: 2
                            },
                            grid: {
                                color: gridColor,
                                lineWidth: 1
                            },
                            border: {
                                color: borderColor,
                                width: 1
                            },
                            title: {
                                display: true,
                                text: 'Date',
                                color: textColor,
                                font: {
                                    size: window.innerWidth < 768 ? 11 : 12,
                                    weight: '600',
                                    family: 'system-ui, -apple-system, sans-serif'
                                },
                                padding: { top: 2, bottom: 2 }
                            }
                        },
                        y: {
                            beginAtZero: false,
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toLocaleString();
                                },
                                font: {
                                    size: window.innerWidth < 768 ? 10 : 11,
                                    weight: '500',
                                    family: 'system-ui, -apple-system, sans-serif'
                                },
                                color: textColor,
                                padding: 2
                            },
                            grid: {
                                color: gridColor,
                                lineWidth: 1
                            },
                            border: {
                                color: borderColor,
                                width: 1
                            },
                            title: {
                                display: true,
                                text: 'Price (USD)',
                                color: textColor,
                                font: {
                                    size: window.innerWidth < 768 ? 11 : 12,
                                    weight: '600',
                                    family: 'system-ui, -apple-system, sans-serif'
                                },
                                padding: { top: 2, bottom: 2 }
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'üìä Price Movement Analysis',
                            font: { 
                                size: window.innerWidth < 768 ? 13 : 15,
                                weight: 'bold',
                                family: 'system-ui, -apple-system, sans-serif'
                            },
                            color: textColor,
                            padding: { top: 4, bottom: 6 }
                        },
                        legend: {
                            display: true,
                            position: window.innerWidth < 768 ? 'bottom' : 'top',
                            labels: {
                                font: {
                                    size: window.innerWidth < 768 ? 10 : 11,
                                    weight: '500',
                                    family: 'system-ui, -apple-system, sans-serif'
                                },
                                padding: 8,
                                usePointStyle: true,
                                boxWidth: window.innerWidth < 768 ? 8 : 10,
                                color: textColor
                            }
                        },
                        subtitle: {
                            display: window.innerWidth >= 768,
                            text: 'üìù Green bars = price increased from previous point, Red bars = price decreased',
                            font: { 
                                size: 10,
                                style: 'italic',
                                weight: '400',
                                family: 'system-ui, -apple-system, sans-serif'
                            },
                            color: textColor,
                            padding: { top: 2, bottom: 6 }
                        },
                        tooltip: {
                            backgroundColor: backgroundColor,
                            titleColor: textColor,
                            bodyColor: textColor,
                            borderColor: borderColor,
                            borderWidth: 1,
                            cornerRadius: 6,
                            titleFont: { 
                                size: window.innerWidth < 768 ? 11 : 12,
                                weight: '600',
                                family: 'system-ui, -apple-system, sans-serif'
                            },
                            bodyFont: { 
                                size: window.innerWidth < 768 ? 10 : 11,
                                weight: '500',
                                family: 'system-ui, -apple-system, sans-serif'
                            },
                            callbacks: {
                                title: function(context) {
                                    return context[0].label;
                                },
                                beforeBody: function(context) {
                                    const timePoint = context[0].parsed.x;
                                    const movement = priceChanges.find(p => p.x.getTime() === new Date(timePoint).getTime());
                                    
                                    if (movement) {
                                        const direction = movement.isPositive ? 'üìà' : 'üìâ';
                                        const changeText = movement.isPositive ? 'Increased' : 'Decreased';
                                        
                                        return [
                                            `${direction} Price ${changeText}:`,
                                            `Current: $${movement.y.toLocaleString()}`,
                                            `Change: ${movement.change >= 0 ? '+' : ''}$${movement.change.toFixed(2)}`,
                                            `Percent: ${movement.change >= 0 ? '+' : ''}${movement.percentChange.toFixed(2)}%`
                                        ];
                                    }
                                    return ['Price point'];
                                },
                                label: function(context) {
                                    const label = context.dataset.label || '';
                                    const value = context.parsed.y;
                                    return `${label}: $${value.toLocaleString()}`;
                                }
                            }
                        }
                    },
                    layout: {
                        padding: { top: 2, bottom: 2, left: 2, right: 2 }
                    },
                    animation: {
                        duration: window.innerWidth < 768 ? 100 : 200,
                        easing: 'easeInOutQuart'
                    }
                }
            });

            // Reliable chart display with proper timing
            setTimeout(() => {
                const canvas = document.getElementById('candleChart');
                
                canvas.style.display = 'block';
                canvas.style.visibility = 'visible';
                canvas.style.opacity = '1';
                canvas.classList.add('visible');
                
                if (candleChartInstance) {
                    candleChartInstance.update();
                    candleChartInstance.resize();
                    
                    // Register chart with responsive manager
                    if (window.taChartManager) {
                        window.taChartManager.registerChart('candleChart', candleChartInstance);
                    }
                    
                    setTimeout(() => {
                        candleChartInstance.render();
                        console.log('‚úÖ Price-based OHLC chart successfully rendered:', {
                            canvasWidth: canvas.clientWidth,
                            canvasHeight: canvas.clientHeight,
                            hasChart: !!candleChartInstance,
                            totalPricePoints: priceData.length,
                            positiveMovements: positiveChanges.length,
                            negativeMovements: negativeChanges.length,
                            datasetsCreated: datasets.length
                        });
                    }, 50);
                }
            }, 100);
        }

        function displayIndicators(rsi, sma20, signals) {
            // ‚úÖ FIX: Robust RSI value extraction with proper fallbacks
            const currentRSI = rsi.length > 0 ? rsi[rsi.length - 1].y : null;
            const rsiDisplay = currentRSI !== null ? currentRSI.toFixed(2) : 'N/A';
            const rsiStatus = currentRSI !== null ? 'Available' : 'Insufficient data (needs 15+ points)';

            const rsiSignal = signals.find(s => s.type === 'RSI');
            const smaSignal = signals.find(s => s.type === 'SMA');
            const bbSignal = signals.find(s => s.type === 'BB');

            // ‚úÖ FIX: Enhanced display with data validation
            document.getElementById('indicators').innerHTML = `
                <div class="indicator">
                    <h3>üìà RSI (14)</h3>
                    <div class="indicator-value">${rsiDisplay}</div>
                    <div class="signal ${rsiSignal.signal.toLowerCase()}">${rsiSignal.signal}</div>
                    <div class="signal-strength">${rsiSignal.strength} Signal</div>
                    <div class="explanation">${rsiSignal.reason}</div>
                    ${currentRSI === null ? `<div style="font-size: 0.8em; color: var(--warning-color); margin-top: 5px;">‚ö†Ô∏è ${rsiStatus}</div>` : ''}
                </div>

                <div class="indicator">
                    <h3>üìä Moving Average (20)</h3>
                    <div class="signal ${smaSignal.signal.toLowerCase()}">${smaSignal.signal}</div>
                    <div class="signal-strength">${smaSignal.strength} Signal</div>
                    <div class="explanation">${smaSignal.reason}</div>
                </div>

                <div class="indicator">
                    <h3>üìè Bollinger Bands</h3>
                    <div class="signal ${bbSignal.signal.toLowerCase()}">${bbSignal.signal}</div>
                    <div class="signal-strength">${bbSignal.strength} Signal</div>
                    <div class="explanation">${bbSignal.reason}</div>
                </div>

                <div class="educational-notes">
                    <strong>üìö Educational Notes:</strong><br>
                    ‚Ä¢ <strong>Why indicators start mid-chart:</strong> SMA(20) requires 20 data points, BB bands require SMA calculation<br>
                    ‚Ä¢ <strong>RSI interpretation:</strong> < 30 potentially oversold, > 70 potentially overbought<br>
                    ‚Ä¢ <strong>SMA signals:</strong> Price above SMA suggests potential uptrend<br>
                    ‚Ä¢ <strong>Bollinger Bands:</strong> Price touching bands may indicate reversal opportunities<br>
                    ‚Ä¢ <strong>Technical accuracy:</strong> Delayed indicator start ensures mathematical correctness
                </div>
            `;
        }

        function displayIndicatorsWithPatterns(rsi, sma20, traditionalSignals, candlePatterns) {
            // Traditional indicators
            const currentRSI = rsi.length > 0 ? rsi[rsi.length - 1].y : null;
            const rsiDisplay = currentRSI !== null ? currentRSI.toFixed(2) : 'N/A';
            const rsiStatus = currentRSI !== null ? 'Available' : 'Insufficient data (needs 15+ points)';

            const rsiSignal = traditionalSignals.find(s => s.type === 'RSI');
            const smaSignal = traditionalSignals.find(s => s.type === 'SMA');
            const bbSignal = traditionalSignals.find(s => s.type === 'BB');

            // Price patterns section (candlestick or price movement patterns)
            let patternsHTML = '';
            const patternTitle = candlePatterns.some(p => p.type.includes('Price')) ? 
                'üìä Price Movement Patterns' : 'üïØÔ∏è Candlestick Patterns';
            
            if (candlePatterns.length > 0) {
                patternsHTML = `
                    <div class="indicator patterns-container">
                        <h3>${patternTitle}</h3>
                        <div style="max-height: 250px; overflow-y: auto;">
                            ${candlePatterns.map(pattern => `
                                <div class="pattern-entry">
                                    <div class="signal ${pattern.signal.toLowerCase()}">${pattern.type}</div>
                                    <div class="signal-strength">${pattern.strength} Signal</div>
                                    <div class="explanation">${pattern.reason}</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            } else {
                patternsHTML = `
                    <div class="indicator">
                        <h3>${patternTitle}</h3>
                        <div class="explanation">No significant patterns detected in recent data.</div>
                    </div>
                `;
            }

            document.getElementById('indicators').innerHTML = `
                <div class="indicator">
                    <h3>üìà RSI (14)</h3>
                    <div class="indicator-value">${rsiDisplay}</div>
                    <div class="signal ${rsiSignal.signal.toLowerCase()}">${rsiSignal.signal}</div>
                    <div class="signal-strength">${rsiSignal.strength} Signal</div>
                    <div class="explanation">${rsiSignal.reason}</div>
                    ${currentRSI === null ? `<div style="font-size: 0.8em; color: var(--warning-color); margin-top: 5px;">‚ö†Ô∏è ${rsiStatus}</div>` : ''}
                </div>

                <div class="indicator">
                    <h3>üìä Moving Average (20)</h3>
                    <div class="signal ${smaSignal.signal.toLowerCase()}">${smaSignal.signal}</div>
                    <div class="signal-strength">${smaSignal.strength} Signal</div>
                    <div class="explanation">${smaSignal.reason}</div>
                </div>

                <div class="indicator">
                    <h3>üìè Bollinger Bands</h3>
                    <div class="signal ${bbSignal.signal.toLowerCase()}">${bbSignal.signal}</div>
                    <div class="signal-strength">${bbSignal.strength} Signal</div>
                    <div class="explanation">${bbSignal.reason}</div>
                </div>

                ${patternsHTML}

                <div class="educational-notes">
                    <strong>üìö Educational Notes:</strong><br>
                    ‚Ä¢ <strong>Technical Indicators:</strong> RSI, SMA, and Bollinger Bands provide quantitative analysis<br>
                    ‚Ä¢ <strong>Candlestick Patterns:</strong> Visual patterns that reveal market psychology and sentiment<br>
                    ‚Ä¢ <strong>Combined Analysis:</strong> Both technical indicators and candlestick patterns work together for comprehensive market analysis<br>
                    ‚Ä¢ <strong>Pattern Recognition:</strong> Doji = indecision, Hammer = potential reversal, Engulfing = strong momentum<br>
                    ‚Ä¢ <strong>AI Enhancement:</strong> Machine learning analyzes all signals together for improved accuracy
                </div>
            `;
        }

        function displaySummary(overallSignal, totalSignals, coin) {
            const signalClass = overallSignal.signal.toLowerCase();
            const emoji = overallSignal.signal === 'BUY' ? 'üöÄ' : overallSignal.signal === 'SELL' ? 'üìâ' : '‚è∏Ô∏è';

            document.getElementById('taSummary').innerHTML = `
                <div class="ta-summary">
                    <h3>üìã Technical Analysis Summary for ${coin}</h3>
                    <div class="overall-signal">${emoji} ${overallSignal.signal}</div>
                    <div class="confidence">Confidence: ${overallSignal.confidence}%</div>
                    <div style="margin-top: 15px; font-size: 0.9em;">
                        Based on ${totalSignals} technical indicators
                    </div>
                    <div style="margin-top: 15px; font-size: 0.85em; opacity: 0.9; border-top: 1px solid rgba(255,255,255,0.3); padding-top: 15px;">
                        <strong>‚ö†Ô∏è Remember:</strong> Technical analysis and AI insights are educational tools, not crystal balls. They help identify trends and patterns, but markets can be unpredictable. Technical indicators may start mid-timeframe due to calculation requirements (e.g., SMA needs 20 data points). AI analysis enhances traditional indicators but should not be solely relied upon. This is educational content only, not investment advice. Always do your own research and never invest more than you can afford to lose.
                    </div>
                </div>
            `;
            
            document.getElementById('taSummary').style.display = 'block';
        }

        // =============================================================================
        // AI-POWERED ANALYSIS FUNCTIONS
        // =============================================================================

        // Global variables to store analysis data for AI processing
        let currentAnalysisData = null;

        /**
         * Perform AI-powered market mood analysis
         * Uses Cohere v2/classify endpoint via worker
         */
        async function performAIAnalysis(priceData, rsi, sma20, bb, signals, coinId) {
            try {
                console.log('ü§ñ Starting AI analysis...');
                
                // ‚úÖ FIX: Extract LIVE current price and indicator values from actual chart data
                const liveCurrentPrice = priceData[priceData.length - 1].y;
                const liveCurrentRSI = rsi.length > 0 ? rsi[rsi.length - 1].y : 50;
                const liveCurrentSMA = sma20.length > 0 ? sma20[sma20.length - 1].y : liveCurrentPrice;
                const liveCurrentBBUpper = bb.upper.length > 0 ? bb.upper[bb.upper.length - 1].y : liveCurrentPrice * 1.05;
                const liveCurrentBBLower = bb.lower.length > 0 ? bb.lower[bb.lower.length - 1].y : liveCurrentPrice * 0.95;
                
                const smaSignal = signals.find(s => s.type === 'SMA')?.signal || 'NEUTRAL';
                const bbSignal = signals.find(s => s.type === 'BB')?.signal || 'NEUTRAL';
                
                console.log(`üìä LIVE Analysis Context: Price=$${liveCurrentPrice.toLocaleString()}, RSI=${liveCurrentRSI.toFixed(1)}, SMA=$${liveCurrentSMA.toLocaleString()}, BB=[$${liveCurrentBBLower.toLocaleString()}-$${liveCurrentBBUpper.toLocaleString()}]`);
                
                // Store LIVE data for potential AI explanation later with actual price context
                currentAnalysisData = {
                    priceData, rsi, sma: sma20, bb, signals, coin: coinId, 
                    timeframe: parseInt(document.getElementById('timeframe').value),
                    currentPrice: liveCurrentPrice,
                    currentRSI: liveCurrentRSI,
                    currentSMA: liveCurrentSMA,
                    currentBBUpper: liveCurrentBBUpper,
                    currentBBLower: liveCurrentBBLower
                };
                
                // Call AI analysis endpoint with LIVE values
                const response = await fetch(`${WORKER_URL}/ai-analysis`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        rsi: liveCurrentRSI,
                        smaSignal: smaSignal,
                        bbSignal: bbSignal,
                        priceData: priceData,
                        coin: coinId
                    }),
                });
                
                if (!response.ok) {
                    throw new Error(`AI Analysis API error: ${response.status}`);
                }
                
                const aiResult = await response.json();
                console.log('ü§ñ AI Analysis result:', aiResult);
                
                // Display AI analysis results
                displayAIAnalysis(aiResult);
                
                // Show the AI Explain button
                document.getElementById('aiExplainBtn').style.display = 'inline-flex';
                
            } catch (error) {
                console.error('‚ùå AI Analysis failed:', error);
                displayAIAnalysisError(error.message);
            }
        }

        /**
         * Display AI analysis results in the UI
         */
        function displayAIAnalysis(aiResult) {
            // Show the AI analysis section
            document.getElementById('aiAnalysisSection').style.display = 'block';
            
            // Update mood icon and label
            const moodIcons = {
                'bullish': 'üöÄ',
                'bearish': 'üêª',
                'neutral': '‚öñÔ∏è'
            };
            
            const aiMoodLabel = document.getElementById('aiMoodLabel');
            const aiMoodIcon = document.getElementById('aiMoodIcon');
            
            // Set icon and text
            aiMoodIcon.textContent = moodIcons[aiResult.mood] || 'ü§ñ';
            aiMoodLabel.textContent = aiResult.mood.toUpperCase();
            
            // ‚úÖ FIX: Apply proper styling classes for better contrast
            aiMoodLabel.className = ''; // Clear existing classes
            aiMoodLabel.classList.add(aiResult.mood); // Add mood-specific class
            
            // Enhanced contrast for different moods
            if (aiResult.mood === 'neutral') {
                // White text with dark background for better contrast on purple
                aiMoodLabel.style.color = '#ffffff';
                aiMoodLabel.style.background = 'rgba(255,255,255,0.25)';
                aiMoodLabel.style.border = '2px solid rgba(255,255,255,0.4)';
                aiMoodLabel.style.padding = '8px 16px';
                aiMoodLabel.style.borderRadius = '8px';
                aiMoodLabel.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                aiMoodLabel.style.fontWeight = '800';
            } else if (aiResult.mood === 'bullish') {
                aiMoodLabel.style.color = '#4ade80';
                aiMoodLabel.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                aiMoodLabel.style.fontWeight = '800';
            } else if (aiResult.mood === 'bearish') {
                aiMoodLabel.style.color = '#f87171';
                aiMoodLabel.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                aiMoodLabel.style.fontWeight = '800';
            }
            
            // Enhanced confidence styling
            const aiConfidence = document.getElementById('aiConfidence');
            aiConfidence.textContent = `Confidence: ${aiResult.confidence}%`;
            aiConfidence.style.color = '#ffffff';
            aiConfidence.style.fontWeight = '600';
            aiConfidence.style.textShadow = '1px 1px 2px rgba(0,0,0,0.6)';
            
            // Update reasoning
            document.getElementById('aiReasoning').textContent = aiResult.reasoning;
            
            // Update method badge
            const methodText = aiResult.method === 'cohere-classify-api' ? 'Cohere AI' : 'Rule-based';
            document.getElementById('aiMethodBadge').textContent = methodText;
        }

        /**
         * Display AI analysis error
         */
        function displayAIAnalysisError(errorMessage) {
            document.getElementById('aiAnalysisSection').style.display = 'block';
            document.getElementById('aiMoodIcon').textContent = '‚ö†Ô∏è';
            document.getElementById('aiMoodLabel').textContent = 'Analysis Failed';
            document.getElementById('aiMoodLabel').style.color = 'var(--danger-color)';
            document.getElementById('aiConfidence').textContent = 'Error occurred';
            document.getElementById('aiReasoning').textContent = `AI analysis temporarily unavailable: ${errorMessage}. Using traditional indicators instead.`;
            document.getElementById('aiMethodBadge').textContent = 'Fallback';
        }

        /**
         * Enhanced AI analysis that includes candlestick patterns
         * Combines traditional indicators with pattern recognition
         */
        async function performAIAnalysisWithPatterns(priceData, rsi, sma20, bb, traditionalSignals, candlePatterns, coinId) {
            try {
                console.log('ü§ñ Starting enhanced AI analysis with candlestick patterns...');
                
                // Extract current values
                const liveCurrentPrice = priceData[priceData.length - 1].y;
                const liveCurrentRSI = rsi.length > 0 ? rsi[rsi.length - 1].y : 50;
                const liveCurrentSMA = sma20.length > 0 ? sma20[sma20.length - 1].y : liveCurrentPrice;
                const liveCurrentBBUpper = bb.upper.length > 0 ? bb.upper[bb.upper.length - 1].y : liveCurrentPrice * 1.05;
                const liveCurrentBBLower = bb.lower.length > 0 ? bb.lower[bb.lower.length - 1].y : liveCurrentPrice * 0.95;
                
                const smaSignal = traditionalSignals.find(s => s.type === 'SMA')?.signal || 'NEUTRAL';
                const bbSignal = traditionalSignals.find(s => s.type === 'BB')?.signal || 'NEUTRAL';
                
                console.log(`üìä Enhanced Analysis Context: Price=$${liveCurrentPrice.toLocaleString()}, RSI=${liveCurrentRSI.toFixed(1)}, Patterns=${candlePatterns.length}`);
                
                // Store enhanced data for AI explanation
                currentAnalysisData = {
                    priceData, rsi, sma: sma20, bb, 
                    signals: [...traditionalSignals, ...candlePatterns], 
                    candlePatterns,
                    coin: coinId, 
                    timeframe: parseInt(document.getElementById('timeframe').value),
                    currentPrice: liveCurrentPrice,
                    currentRSI: liveCurrentRSI,
                    currentSMA: liveCurrentSMA,
                    currentBBUpper: liveCurrentBBUpper,
                    currentBBLower: liveCurrentBBLower
                };
                
                // Call enhanced AI analysis endpoint
                const response = await fetch(`${WORKER_URL}/ai-analysis-enhanced`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        rsi: liveCurrentRSI,
                        smaSignal: smaSignal,
                        bbSignal: bbSignal,
                        priceData: priceData,
                        candlePatterns: candlePatterns,
                        coin: coinId
                    }),
                });
                
                if (!response.ok) {
                    // Fallback to regular AI analysis if enhanced endpoint not available
                    console.log('Enhanced AI endpoint not available, falling back to regular analysis...');
                    return await performAIAnalysis(priceData, rsi, sma20, bb, traditionalSignals, coinId);
                }
                
                const aiResult = await response.json();
                console.log('ü§ñ Enhanced AI Analysis result:', aiResult);
                
                // Display enhanced AI analysis results
                displayEnhancedAIAnalysis(aiResult);
                
                // Show the AI Explain button
                document.getElementById('aiExplainBtn').style.display = 'inline-flex';
                
            } catch (error) {
                console.error('‚ùå Enhanced AI Analysis failed:', error);
                // Fallback to regular AI analysis
                console.log('Falling back to regular AI analysis...');
                return await performAIAnalysis(priceData, rsi, sma20, bb, traditionalSignals, coinId);
            }
        }

        /**
         * Display enhanced AI analysis results with candlestick pattern context
         */
        function displayEnhancedAIAnalysis(aiResult) {
            // Show the AI analysis section
            document.getElementById('aiAnalysisSection').style.display = 'block';
            
            // Update mood icon and label
            const moodIcons = {
                'bullish': 'üöÄ',
                'bearish': 'üêª',
                'neutral': '‚öñÔ∏è'
            };
            
            const aiMoodLabel = document.getElementById('aiMoodLabel');
            const aiMoodIcon = document.getElementById('aiMoodIcon');
            
            // Set icon and text
            aiMoodIcon.textContent = moodIcons[aiResult.mood] || 'ü§ñ';
            aiMoodLabel.textContent = aiResult.mood.toUpperCase();
            
            // Apply enhanced styling for mood
            aiMoodLabel.className = '';
            aiMoodLabel.classList.add(aiResult.mood);
            
            if (aiResult.mood === 'neutral') {
                aiMoodLabel.style.color = '#ffffff';
                aiMoodLabel.style.background = 'rgba(255,255,255,0.25)';
                aiMoodLabel.style.border = '2px solid rgba(255,255,255,0.4)';
                aiMoodLabel.style.padding = '8px 16px';
                aiMoodLabel.style.borderRadius = '8px';
                aiMoodLabel.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                aiMoodLabel.style.fontWeight = '800';
            } else if (aiResult.mood === 'bullish') {
                aiMoodLabel.style.color = '#4ade80';
                aiMoodLabel.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                aiMoodLabel.style.fontWeight = '800';
            } else if (aiResult.mood === 'bearish') {
                aiMoodLabel.style.color = '#f87171';
                aiMoodLabel.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                aiMoodLabel.style.fontWeight = '800';
            }
            
            // Enhanced confidence styling
            const aiConfidence = document.getElementById('aiConfidence');
            aiConfidence.textContent = `Confidence: ${aiResult.confidence}%`;
            aiConfidence.style.color = '#ffffff';
            aiConfidence.style.fontWeight = '600';
            aiConfidence.style.textShadow = '1px 1px 2px rgba(0,0,0,0.6)';
            
            // Update reasoning with pattern context
            const reasoning = aiResult.reasoning + (aiResult.patterns ? `\n\nCandlestick Patterns: ${aiResult.patterns}` : '');
            document.getElementById('aiReasoning').textContent = reasoning;
            
            // Update method badge
            const methodText = aiResult.method === 'cohere-enhanced-api' ? 'Cohere AI Enhanced' : 
                              aiResult.method === 'cohere-classify-api' ? 'Cohere AI' : 'Rule-based';
            document.getElementById('aiMethodBadge').textContent = methodText;
        }

        /**
         * Get AI explanation of current pattern
         * Uses Cohere v2/chat endpoint via worker
         */
        async function getAIExplanation() {
            if (!currentAnalysisData) {
                alert('Please run an analysis first!');
                return;
            }
            
            try {
                console.log('üß† Generating AI explanation...');
                
                // Show loading state
                document.getElementById('aiExplanationSection').style.display = 'block';
                document.getElementById('aiExplanationContent').innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px; color: var(--text-secondary);">
                        <div class="loading-spinner"></div>
                        Generating AI explanation...
                    </div>
                `;
                
                // ‚úÖ FIX: Extract LIVE values from current chart data for most accurate AI explanation
                const latestPriceData = currentAnalysisData.priceData;
                const latestRSIData = currentAnalysisData.rsi;
                const latestSMAData = currentAnalysisData.sma;
                const latestBBData = currentAnalysisData.bb;
                
                // Get the actual LATEST values from the arrays (what's shown on chart)
                const liveCurrentPrice = latestPriceData[latestPriceData.length - 1].y;
                const liveCurrentRSI = latestRSIData.length > 0 ? latestRSIData[latestRSIData.length - 1].y : 50;
                const liveCurrentSMA = latestSMAData.length > 0 ? latestSMAData[latestSMAData.length - 1].y : liveCurrentPrice;
                const liveCurrentBBUpper = latestBBData.upper.length > 0 ? latestBBData.upper[latestBBData.upper.length - 1].y : liveCurrentPrice * 1.05;
                const liveCurrentBBLower = latestBBData.lower.length > 0 ? latestBBData.lower[latestBBData.lower.length - 1].y : liveCurrentPrice * 0.95;
                
                console.log(`üìä LIVE Chart Values - Price: $${liveCurrentPrice.toLocaleString()}, RSI: ${liveCurrentRSI.toFixed(1)}, SMA: $${liveCurrentSMA.toLocaleString()}, BB: [$${liveCurrentBBLower.toLocaleString()}-$${liveCurrentBBUpper.toLocaleString()}]`);
                
                // ‚úÖ FIX: Use LIVE chart values for AI explanation instead of potentially stale stored values
                const explanationData = {
                    rsi: currentAnalysisData.rsi,
                    sma: currentAnalysisData.sma,
                    bb: currentAnalysisData.bb,
                    signals: currentAnalysisData.signals,
                    coin: currentAnalysisData.coin,
                    timeframe: currentAnalysisData.timeframe,
                    priceData: currentAnalysisData.priceData,
                    // Include LIVE price context for accurate AI explanations
                    currentPrice: liveCurrentPrice,
                    currentRSI: liveCurrentRSI,
                    currentSMA: liveCurrentSMA,
                    currentBBUpper: liveCurrentBBUpper,
                    currentBBLower: liveCurrentBBLower
                };
                
                console.log('üìä Sending LIVE AI explanation data:', explanationData);
                
                // Call AI explanation endpoint
                const response = await fetch(`${WORKER_URL}/ai-explain`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(explanationData),
                });
                
                if (!response.ok) {
                    throw new Error(`AI Explanation API error: ${response.status}`);
                }
                
                const aiExplanation = await response.json();
                console.log('üß† AI Explanation result:', aiExplanation);
                
                // Display explanation
                displayAIExplanation(aiExplanation);
                
            } catch (error) {
                console.error('‚ùå AI Explanation failed:', error);
                displayAIExplanationError(error.message);
            }
        }

        /**
         * Display AI explanation results
         */
        function displayAIExplanation(aiExplanation) {
            // Format the explanation with proper line breaks
            const formattedExplanation = aiExplanation.explanation
                .replace(/\n\n/g, '</p><p>')
                .replace(/\n/g, '<br>');
            
            document.getElementById('aiExplanationContent').innerHTML = `<p>${formattedExplanation}</p>`;
            
            // Update method badge
            const methodText = aiExplanation.method === 'cohere-chat-api' ? 'Cohere AI' : 'Rule-based';
            document.getElementById('explainMethodBadge').textContent = methodText;
        }

        /**
         * Display AI explanation error
         */
        function displayAIExplanationError(errorMessage) {
            document.getElementById('aiExplanationContent').innerHTML = `
                <div style="color: var(--danger-color);">
                    <strong>‚ö†Ô∏è AI Explanation Failed:</strong><br>
                    ${errorMessage}<br><br>
                    <em>Try again in a moment or refer to the technical indicators above for manual analysis.</em>
                </div>
            `;
            document.getElementById('explainMethodBadge').textContent = 'Error';
        }

        // Add CSS animation for loading spinner and mobile optimizations
        const style = document.createElement('style');
        style.textContent = `
            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }
            
            @keyframes fadeIn {
                0% { opacity: 0; transform: translateY(10px); }
                100% { opacity: 1; transform: translateY(0); }
            }
            
            .loading-spinner {
                width: 20px;
                height: 20px;
                border: 2px solid var(--border-color);
                border-top: 2px solid var(--accent-color);
                border-radius: 50%;
                animation: spin 1s linear infinite;
            }
            
            /* üõ†Ô∏è FIX: Mobile-specific AI section improvements with enhanced theme support */
            @media (max-width: 768px) {
                #aiAnalysisSection > div > div {
                    grid-template-columns: 1fr !important;
                }
                
                #aiExplainBtn {
                    width: 100% !important;
                    margin-bottom: 5px;
                }
                
                /* Smooth animations for mobile */
                .indicator {
                    animation: fadeIn 0.3s ease-out;
                }
                
                /* Better chart container on mobile */
                .chart-container h3 {
                    font-size: 1.1em;
                    margin-bottom: 10px;
                }
                
                /* Improved loading state with better contrast */
                .loading {
                    padding: 20px;
                    font-size: 0.9em;
                    color: var(--text-primary);
                    background: var(--bg-secondary);
                    border-radius: 8px;
                    border: 1px solid var(--border-color);
                }
                
                /* Enhanced error state for mobile */
                .error {
                    font-size: 0.85em;
                    padding: 1rem;
                    border-radius: 8px;
                }
            }
            
            /* Accessibility improvements */
            @media (prefers-reduced-motion: reduce) {
                .loading-spinner {
                    animation: none !important;
                }
                * {
                    animation-duration: 0.01ms !important;
                    animation-iteration-count: 1 !important;
                    transition-duration: 0.01ms !important;
                }
            }
        `;
        document.head.appendChild(style);

        // =============================================================================
        // ENHANCED ANALYSIS FUNCTION WITH AI INTEGRATION
        // =============================================================================

        // Enhanced analyzeTA function that includes AI analysis
        async function analyzeTA() {
            const coinId = document.getElementById('coinSelect').value;
            const timeframe = parseInt(document.getElementById('timeframe').value);
            
            // üîß FIXED: Destroy test chart if it exists
            if (window.testChartInstance) {
                // Unregister test chart from responsive manager
                if (window.taChartManager) {
                    window.taChartManager.unregisterChart('taChart');
                }
                window.testChartInstance.destroy();
                window.testChartInstance = null;
                console.log('üß™ Test chart destroyed, starting real analysis...');
            }
            
            // ‚úÖ SCROLL FIX: Prevent any automatic scrolling during analysis
            const currentScrollPosition = window.pageYOffset;
            
            // Show loading states for both charts
            document.getElementById('loading').style.display = 'block';
            document.getElementById('candleLoading').style.display = 'block';
            document.getElementById('taChart').style.display = 'none';
            document.getElementById('candleChart').style.display = 'none';
            document.getElementById('indicators').innerHTML = '<div class="loading">Calculating indicators...</div>';
            document.getElementById('taSummary').style.display = 'none';
            // Hide AI sections initially
            document.getElementById('aiAnalysisSection').style.display = 'none';
            document.getElementById('aiExplainBtn').style.display = 'none';
            document.getElementById('chartError').style.display = 'none';
            document.getElementById('candleError').style.display = 'none';

            try {
                console.log(`Starting analysis for ${coinId} over ${timeframe} days`);
                
                // Fetch both price data and OHLC data in parallel
                const [priceData, ohlcData] = await Promise.all([
                    fetchPriceData(coinId, timeframe),
                    fetchOHLCData(coinId, timeframe)
                ]);
                
                // Calculate indicators
                console.log('Calculating technical indicators...');
                const sma20 = calculateSMA(priceData, 20);
                const rsi = calculateRSI(priceData);
                const bb = calculateBollingerBands(priceData);
                
                // Analyze candlestick patterns (use price data if no OHLC)
                console.log('Analyzing candlestick patterns...');
                const candlePatterns = ohlcData.length > 0 ? 
                    analyzeCandlestickPatterns(ohlcData) : 
                    analyzePriceMovementPatterns(priceData);
                
                console.log('Indicators calculated:', {
                    pricePoints: priceData.length,
                    ohlcPoints: ohlcData.length,
                    smaPoints: sma20.length,
                    rsiPoints: rsi.length,
                    bbPoints: bb.upper.length,
                    candlePatterns: candlePatterns.length
                });
                
                // Generate signals (including candlestick patterns)
                const traditionalSignals = generateTradingSignals(priceData, rsi, sma20, bb);
                const allSignals = [...traditionalSignals, ...candlePatterns];
                const overallSignal = calculateOverallSignal(allSignals);
                
                // Display both charts
                console.log('Creating charts...');
                displayChart(priceData, sma20, bb);
                
                // Always display OHLC section, create fallback if needed
                if (ohlcData && ohlcData.length > 0) {
                    displayCandlestickChart(ohlcData, coinId);
                } else {
                    console.warn('No valid OHLC data available, creating price-based visualization...');
                    // Create simple price-based OHLC visualization
                    displayPriceBasedOHLC(priceData, coinId);
                }
                
                // Update indicators display to include candlestick patterns
                displayIndicatorsWithPatterns(rsi, sma20, traditionalSignals, candlePatterns);
                displaySummary(overallSignal, allSignals.length, coinId.toUpperCase());
                
                // Final backup check to ensure charts are visible
                setTimeout(() => {
                    const canvas = document.getElementById('taChart');
                    const candleCanvas = document.getElementById('candleChart');
                    
                    if (canvas && chartInstance && (canvas.clientWidth === 0 || canvas.clientHeight === 0 || canvas.style.display === 'none')) {
                        console.log('üîß Chart not visible, attempting backup display...');
                        forceChartDisplay();
                    }
                    
                    if (candleCanvas && candleChartInstance && (candleCanvas.clientWidth === 0 || candleCanvas.clientHeight === 0 || candleCanvas.style.display === 'none')) {
                        console.log('üîß Candlestick chart not visible, forcing display...');
                        candleCanvas.style.display = 'block';
                        candleCanvas.style.visibility = 'visible';
                        candleCanvas.classList.add('visible');
                        candleChartInstance.update();
                        candleChartInstance.resize();
                    }
                }, 500);
                
                // ü§ñ PERFORM AI ANALYSIS (enhanced with candlestick patterns)
                console.log('ü§ñ Starting AI integration with candlestick patterns...');
                await performAIAnalysisWithPatterns(priceData, rsi, sma20, bb, traditionalSignals, candlePatterns, coinId);
                
                document.getElementById('loading').style.display = 'none';
                document.getElementById('candleLoading').style.display = 'none';
                console.log('Analysis complete!');
                
                // Chart analysis complete
                console.log('‚úÖ Technical analysis complete with both charts displayed!');
                
                // ‚úÖ SCROLL FIX: Restore scroll position to prevent unwanted scrolling
                window.scrollTo(0, currentScrollPosition);
                
            } catch (error) {
                console.error('Analysis error:', error);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('candleLoading').style.display = 'none';
                document.getElementById('chartError').style.display = 'block';
                document.getElementById('candleError').style.display = 'block';
                document.getElementById('chartError').innerHTML = `<strong>‚ö†Ô∏è Analysis Failed:</strong> ${error.message}. Please try a longer timeframe or check your connection.`;
                document.getElementById('candleError').innerHTML = `<strong>‚ö†Ô∏è Candlestick Chart Failed:</strong> ${error.message}`;
                document.getElementById('indicators').innerHTML = '<div class="error">Analysis failed - please try again with a longer timeframe</div>';
                // ‚úÖ SCROLL FIX: Restore scroll position even on error
                window.scrollTo(0, currentScrollPosition);
            }
        }

        // Theme toggle functionality
        function handleThemeToggle() {
            document.body.classList.toggle('dark-theme');
            const isDark = document.body.classList.contains('dark-theme');
            
            document.getElementById('themeToggle').textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
            
            // Save theme preference
            localStorage.setItem('cryptoDashboardTheme', isDark ? 'dark' : 'light');
        }

        // üîß FIXED: Test chart functionality
        function testChart() {
            const canvas = document.getElementById('taChart');
            const ctx = canvas.getContext('2d');
            
            // Simple test chart to verify Chart.js is working
            const testChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: ['Day 1', 'Day 2', 'Day 3', 'Day 4', 'Day 5'],
                    datasets: [{
                        label: 'Test Data',
                        data: [100, 150, 120, 180, 160],
                        borderColor: '#3B82F6',
                        backgroundColor: '#3B82F620',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'üìä Chart Test - Click Analyze to Load Real Data',
                            font: { size: 18, weight: 'bold' }
                        }
                    }
                }
            });
            
            // Show test chart
            canvas.style.display = 'block';
            canvas.style.visibility = 'visible';
            canvas.classList.add('visible');
            
            return testChart;
        }

        // Enhanced Responsive Chart Management for TA Module
        class TAResponsiveChartManager {
            constructor() {
                this.charts = new Map();
                this.resizeTimeout = null;
                this.orientationTimeout = null;
                this.isInitialized = false;
            }
            
            registerChart(chartId, chartInstance) {
                this.charts.set(chartId, chartInstance);
                console.log(`üìä Registered chart: ${chartId}`);
            }
            
            unregisterChart(chartId) {
                if (this.charts.has(chartId)) {
                    this.charts.delete(chartId);
                    console.log(`üóëÔ∏è Unregistered chart: ${chartId}`);
                }
            }
            
            resizeAllCharts() {
                console.log('üîÑ Resizing all TA charts...');
                let resizedCount = 0;
                
                this.charts.forEach((chart, chartId) => {
                    try {
                        if (chart && typeof chart.resize === 'function') {
                            // Ensure container is visible before resizing
                            const canvas = document.getElementById(chartId);
                            const container = canvas?.closest('.ta-responsive-chart-container');
                            
                            if (container && this.isContainerVisible(container)) {
                                chart.resize();
                                chart.update('none'); // Update without animation for better performance
                                resizedCount++;
                                console.log(`‚úÖ Resized chart: ${chartId}`);
                            }
                        }
                    } catch (error) {
                        console.error(`‚ùå Error resizing chart ${chartId}:`, error);
                    }
                });
                
                console.log(`üìä Resized ${resizedCount} charts successfully`);
            }
            
            isContainerVisible(container) {
                const rect = container.getBoundingClientRect();
                return rect.width > 0 && rect.height > 0;
            }
            
            handleResize() {
                clearTimeout(this.resizeTimeout);
                this.resizeTimeout = setTimeout(() => {
                    this.resizeAllCharts();
                    
                    // Additional mobile optimizations
                    if (window.innerWidth <= 768) {
                        this.optimizeForMobile();
                    }
                }, 200);
            }
            
            handleOrientationChange() {
                clearTimeout(this.orientationTimeout);
                this.orientationTimeout = setTimeout(() => {
                    console.log('üì± Orientation changed, optimizing charts...');
                    this.resizeAllCharts();
                    
                    // Force re-render after orientation change
                    this.charts.forEach((chart, chartId) => {
                        try {
                            if (chart && typeof chart.render === 'function') {
                                chart.render();
                            }
                        } catch (error) {
                            console.error(`‚ùå Error re-rendering chart ${chartId} after orientation change:`, error);
                        }
                    });
                }, 500);
            }
            
            optimizeForMobile() {
                console.log('üì± Applying mobile optimizations...');
                
                // Ensure chart containers have proper mobile classes
                document.querySelectorAll('.ta-responsive-chart-container').forEach(container => {
                    if (!container.classList.contains('mobile-optimized')) {
                        container.classList.add('mobile-optimized');
                        container.style.width = '100%';
                        container.style.maxWidth = '100%';
                        container.style.boxSizing = 'border-box';
                    }
                });
                
                // Ensure chart wrappers are properly sized
                document.querySelectorAll('.ta-responsive-chart-wrapper').forEach(wrapper => {
                    wrapper.style.width = '100%';
                    wrapper.style.maxWidth = 'calc(100vw - 1rem)';
                    wrapper.style.overflow = 'visible';
                });
            }
            
            initialize() {
                if (this.isInitialized) return;
                
                console.log('üöÄ Initializing TA Responsive Chart Manager...');
                
                // Add resize listener
                window.addEventListener('resize', () => this.handleResize());
                
                // Add orientation change listener
                window.addEventListener('orientationchange', () => this.handleOrientationChange());
                
                // Initial mobile optimization if needed
                if (window.innerWidth <= 768) {
                    setTimeout(() => this.optimizeForMobile(), 100);
                }
                
                this.isInitialized = true;
                console.log('‚úÖ TA Responsive Chart Manager initialized');
            }
            
            destroy() {
                clearTimeout(this.resizeTimeout);
                clearTimeout(this.orientationTimeout);
                this.charts.clear();
                this.isInitialized = false;
            }
        }
        
        // Create global instance
        window.taChartManager = new TAResponsiveChartManager();
        
        // Initialize theme and Bitcoin analysis
        window.onload = function() {
            // Load theme preference
            const savedTheme = localStorage.getItem('cryptoDashboardTheme');
            if (savedTheme === 'dark') {
                document.body.classList.add('dark-theme');
                document.getElementById('themeToggle').textContent = '‚òÄÔ∏è';
            }
            
            // Set up theme toggle event listener
            document.getElementById('themeToggle').addEventListener('click', handleThemeToggle);
            
            // Initialize responsive chart manager
            window.taChartManager.initialize();
            
            // üîß FIXED: Show test chart to verify Chart.js is working
            setTimeout(() => {
                const testChartInstance = testChart();
                console.log('üß™ Test chart displayed - Chart.js is working!');
                
                // Store reference to destroy when real analysis runs
                window.testChartInstance = testChartInstance;
                
                // Register test chart for responsive handling
                if (testChartInstance) {
                    window.taChartManager.registerChart('taChart', testChartInstance);
                }
            }, 100);
            
            // You can uncomment the line below to auto-analyze Bitcoin on page load
            // analyzeTA();
        };
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (window.taChartManager) {
                window.taChartManager.destroy();
                console.log('üßπ TA Chart Manager cleaned up on page unload');
            }
        });
    </script>
</body>
</html> 