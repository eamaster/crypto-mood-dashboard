<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîç Technical Analysis Module - Crypto Dashboard</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üìà</text></svg>">
    <link rel="stylesheet" href="../style.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <!-- Removed problematic candlestick library - using custom implementation -->
</head>
<body>
    <header>
        <div class="header-content">
            <h1>üîç Technical Analysis Module</h1>
            <button id="themeToggle" class="theme-toggle">üåô</button>
        </div>
    </header>

    <main>
        <div class="ta-container">
            <div class="ta-header">
                <p class="subtitle">Professional crypto technical indicators and signals</p>
            </div>

        <div class="controls">
            <div class="control-group">
                <label for="coinSelect">Cryptocurrency:</label>
                <select id="coinSelect">
                    <option value="bitcoin">Bitcoin (BTC)</option>
                    <option value="ethereum">Ethereum (ETH)</option>
                    <option value="dogecoin">Dogecoin (DOGE)</option>
                    <option value="cardano">Cardano (ADA)</option>
                    <option value="solana">Solana (SOL)</option>
                    <option value="litecoin">Litecoin (LTC)</option>
                    <option value="bitcoin-cash">Bitcoin Cash (BCH)</option>
                    <option value="ripple">Ripple (XRP)</option>
                    <option value="polkadot">Polkadot (DOT)</option>
                    <option value="chainlink">Chainlink (LINK)</option>
                    <option value="stellar">Stellar (XLM)</option>
                    <option value="monero">Monero (XMR)</option>
                    <option value="tezos">Tezos (XTZ)</option>
                    <option value="eos">EOS (EOS)</option>
                    <option value="zcash">Zcash (ZEC)</option>
                    <option value="dash">Dash (DASH)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="timeframe">Timeframe:</label>
                <select id="timeframe">
                    <option value="7">7 Days</option>
                    <option value="14">14 Days</option>
                    <option value="30">30 Days</option>
                </select>
            </div>
            
            <div class="button-group">
                <button onclick="analyzeTA()">üîç Analyze</button>
                <button id="aiExplainBtn" onclick="getAIExplanation()" style="display: none;">ü§ñ AI Explain This</button>
                <button onclick="location.href='../index.html'" class="ta-button">üè† Back to Dashboard</button>
            </div>
        </div>

        <div class="ta-charts-grid">
            <div class="ta-chart-column left">
                <div class="ta-responsive-chart-container">
                    <h3>üìà Price Chart with Technical Indicators</h3>
                    <div class="chart-info-box">
                        <strong>‚ÑπÔ∏è Chart Information:</strong> Technical indicators (SMA, Bollinger Bands) start after collecting sufficient data points for accurate calculations. This delayed start is mathematically correct and ensures reliable signals.
                        <br><strong>ü§ñ AI Enhancement:</strong> Advanced AI analysis will automatically classify market mood and provide pattern explanations below the chart.
                    </div>
                    <div id="loading" class="loading" style="display: none;">Fetching data and calculating indicators...</div>
                    <div class="ta-responsive-chart-wrapper">
                        <canvas id="taChart"></canvas>
                    </div>
                    <div id="chartError" class="error" style="display: none;"></div>
                </div>

                <div class="ta-responsive-chart-container">
                    <h3>üìä Price Movement Analysis</h3>
                    <div class="chart-info-box">
                        <strong>‚ÑπÔ∏è Price Analysis Information:</strong> Shows price movements over time. Green bars = price increased from previous period, Red bars = price decreased, Blue line = overall trend.
                        <br><strong>üìä Visual Analysis:</strong> Bar heights represent actual price levels. Color patterns reveal market sentiment and momentum changes over the selected timeframe.
                        <br><strong>üîß Pattern Recognition:</strong> Consecutive price movements and trend changes help identify potential trading opportunities and market psychology.
                    </div>
                    <div id="candleLoading" class="loading" style="display: none;">Fetching OHLC data...</div>
                    <div class="ta-responsive-chart-wrapper">
                        <canvas id="candleChart"></canvas>
                    </div>
                    <div id="candleError" class="error" style="display: none;"></div>
                </div>
            </div>

            <div class="ta-chart-column right">
                <div class="indicators-panel">
                    <h3>üìä Technical Indicators</h3>
                    <div id="indicators">
                        <div class="loading">Analysis results will appear here...</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- AI-Powered Analysis Section -->
        <div id="aiAnalysisSection" style="display: none;">
            <div class="ai-analysis-card">
                <h3 class="ai-analysis-header">
                    ü§ñ AI-Powered Market Analysis
                    <span id="aiMethodBadge" class="ai-method-badge"></span>
                </h3>
                
                <div class="ai-analysis-grid">
                    <div class="ai-mood-display">
                        <div id="aiMoodIcon" class="ai-mood-icon">ü§ñ</div>
                        <div id="aiMoodLabel" class="ai-mood-label">Analyzing...</div>
                        <div id="aiConfidence" class="ai-confidence">Confidence: --</div>
                    </div>
                    
                    <div class="ai-reasoning-container">
                        <div id="aiReasoning" class="ai-reasoning">
                            Generating AI analysis...
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- AI Explanation Section -->
            <div id="aiExplanationSection" style="display: none;" class="ai-explanation-card">
                <h3 class="ai-explanation-header">
                    üß† AI Pattern Explanation
                    <span id="explainMethodBadge" class="ai-explain-badge"></span>
                </h3>
                <div id="aiExplanationContent" class="ai-explanation-content">
                    Click "AI Explain This" to get a detailed explanation of the current market pattern.
                </div>
            </div>
        </div>

        <div id="taSummary" style="display: none;"></div>
        </div>
    </main>

    <footer>
        <p>Data from Blockchair & <a href="https://newsapi.org/" target="_blank" rel="noopener">NewsAPI.org</a> ‚Ä¢ AI by Cohere ‚Ä¢ Built with Chart.js & Cloudflare Workers</p>
        <p><a href="../index.html">üè† Back to Dashboard</a> ‚Ä¢ <a href="index.html">üì¶ View all modules</a></p>
    </footer>

    <script>
        // Filter out browser extension errors from console
        const originalError = console.error;
        const originalWarn = console.warn;
        
        console.error = function(...args) {
            const message = args.join(' ');
            if (message.includes('runtime.lastError') || 
                message.includes('message port closed') || 
                message.includes('content script') ||
                message.includes('Receiving end does not exist') ||
                message.includes('message channel closed') ||
                message.includes('listener indicated an asynchronous response')) {
                return; // Ignore extension errors
            }
            originalError.apply(console, args);
        };
        
        // Also filter console warnings for extension-related issues
        console.warn = function(...args) {
            const message = args.join(' ');
            if (message.includes('runtime.lastError') || 
                message.includes('extension')) {
                return; // Ignore extension warnings
            }
            originalWarn.apply(console, args);
        };

        // Worker URL - Update this to your deployed worker
        const WORKER_URL = 'https://crypto-mood-dashboard.smah0085.workers.dev';
        
        let chartInstance = null;
        let candleChartInstance = null;
        
        // Backup function to force chart display if primary method fails
        function forceChartDisplay() {
            const canvas = document.getElementById('taChart');
            if (canvas && chartInstance) {
                console.log('üîß Forcing chart display as backup...');
                
                // Apply essential styles directly
                canvas.style.display = 'block';
                canvas.style.visibility = 'visible';
                canvas.style.opacity = '1';
                canvas.style.width = '100%';
                canvas.style.height = '420px';
                canvas.style.position = 'relative';
                canvas.style.zIndex = '10';
                canvas.classList.add('visible');
                
                // Force Chart.js to re-render
                chartInstance.update();
                chartInstance.resize();
                chartInstance.render();
                
                console.log('‚úÖ Backup chart display completed');
            }
        }

        // Technical Analysis Functions
        function calculateSMA(data, period) {
            const sma = [];
            for (let i = period - 1; i < data.length; i++) {
                const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b.y, 0);
                sma.push({
                    x: data[i].x,
                    y: sum / period
                });
            }
            return sma;
        }

        function calculateRSI(data, period = 14) {
            const changes = [];
            for (let i = 1; i < data.length; i++) {
                changes.push(data[i].y - data[i - 1].y);
            }

            let avgGain = 0;
            let avgLoss = 0;

            // Initial average
            for (let i = 0; i < period; i++) {
                if (changes[i] > 0) avgGain += changes[i];
                else avgLoss += Math.abs(changes[i]);
            }
            avgGain /= period;
            avgLoss /= period;

            const rsi = [];
            for (let i = period; i < changes.length; i++) {
                if (changes[i] > 0) {
                    avgGain = (avgGain * (period - 1) + changes[i]) / period;
                    avgLoss = (avgLoss * (period - 1)) / period;
                } else {
                    avgGain = (avgGain * (period - 1)) / period;
                    avgLoss = (avgLoss * (period - 1) + Math.abs(changes[i])) / period;
                }

                const rs = avgGain / avgLoss;
                const rsiValue = 100 - (100 / (1 + rs));
                rsi.push({
                    x: data[i + 1].x,
                    y: rsiValue
                });
            }
            return rsi;
        }

        function calculateBollingerBands(data, period = 20, stdDev = 2) {
            const sma = calculateSMA(data, period);
            const bands = { upper: [], middle: [], lower: [] };
            
            for (let i = 0; i < sma.length; i++) {
                const dataSlice = data.slice(i, i + period);
                const mean = sma[i].y;
                const variance = dataSlice.reduce((sum, point) => sum + Math.pow(point.y - mean, 2), 0) / period;
                const standardDeviation = Math.sqrt(variance);
                
                bands.middle.push(sma[i]);
                bands.upper.push({
                    x: sma[i].x,
                    y: mean + (standardDeviation * stdDev)
                });
                bands.lower.push({
                    x: sma[i].x,
                    y: mean - (standardDeviation * stdDev)
                });
            }
            
            return bands;
        }

        function generateTradingSignals(price, rsi, sma, bb) {
            const signals = [];
            const currentPrice = price[price.length - 1].y;
            
            // ‚úÖ FIX: Robust indicator value extraction with null checks
            const currentRSI = rsi.length > 0 ? rsi[rsi.length - 1].y : null;
            const currentSMA = sma.length > 0 ? sma[sma.length - 1].y : null;
            const currentBBUpper = bb.upper.length > 0 ? bb.upper[bb.upper.length - 1].y : null;
            const currentBBLower = bb.lower.length > 0 ? bb.lower[bb.lower.length - 1].y : null;

            // RSI Signals - only generate if RSI is available
            if (currentRSI !== null) {
                if (currentRSI < 30) {
                    signals.push({ type: 'RSI', signal: 'BUY', strength: 'Strong', reason: `Oversold condition (RSI ${currentRSI.toFixed(1)} < 30)` });
                } else if (currentRSI > 70) {
                    signals.push({ type: 'RSI', signal: 'SELL', strength: 'Strong', reason: `Overbought condition (RSI ${currentRSI.toFixed(1)} > 70)` });
                } else {
                    signals.push({ type: 'RSI', signal: 'NEUTRAL', strength: 'Weak', reason: `RSI ${currentRSI.toFixed(1)} in normal range (30-70)` });
                }
            } else {
                signals.push({ type: 'RSI', signal: 'NEUTRAL', strength: 'Weak', reason: 'RSI calculation pending (need 15+ data points)' });
            }

            // Moving Average Signals - only generate if SMA is available
            if (currentSMA !== null) {
                if (currentPrice > currentSMA * 1.02) {
                    signals.push({ type: 'SMA', signal: 'BUY', strength: 'Medium', reason: `Price $${currentPrice.toLocaleString()} above SMA $${currentSMA.toLocaleString()}` });
                } else if (currentPrice < currentSMA * 0.98) {
                    signals.push({ type: 'SMA', signal: 'SELL', strength: 'Medium', reason: `Price $${currentPrice.toLocaleString()} below SMA $${currentSMA.toLocaleString()}` });
                } else {
                    signals.push({ type: 'SMA', signal: 'NEUTRAL', strength: 'Weak', reason: `Price $${currentPrice.toLocaleString()} near SMA $${currentSMA.toLocaleString()}` });
                }
            } else {
                signals.push({ type: 'SMA', signal: 'NEUTRAL', strength: 'Weak', reason: 'SMA calculation pending (need 20+ data points)' });
            }

            // Bollinger Bands Signals - only generate if BB is available
            if (currentBBUpper !== null && currentBBLower !== null) {
                if (currentPrice < currentBBLower) {
                    signals.push({ type: 'BB', signal: 'BUY', strength: 'Medium', reason: `Price $${currentPrice.toLocaleString()} below lower band $${currentBBLower.toLocaleString()}` });
                } else if (currentPrice > currentBBUpper) {
                    signals.push({ type: 'BB', signal: 'SELL', strength: 'Medium', reason: `Price $${currentPrice.toLocaleString()} above upper band $${currentBBUpper.toLocaleString()}` });
                } else {
                    signals.push({ type: 'BB', signal: 'NEUTRAL', strength: 'Weak', reason: `Price $${currentPrice.toLocaleString()} within bands $${currentBBLower.toLocaleString()}-$${currentBBUpper.toLocaleString()}` });
                }
            } else {
                signals.push({ type: 'BB', signal: 'NEUTRAL', strength: 'Weak', reason: 'Bollinger Bands calculation pending (need 20+ data points)' });
            }

            return signals;
        }

        function analyzeCandlestickPatterns(ohlcData) {
            const patterns = [];
            
            if (ohlcData.length < 2) {
                console.log('üìä Insufficient data for pattern analysis');
                return patterns;
            }
            
            console.log(`üîç Analyzing patterns in ${ohlcData.length} OHLC periods...`);
            
            // Analyze all candles for patterns (not just last few)
            for (let i = 1; i < ohlcData.length; i++) {
                const candle = ohlcData[i];
                const prevCandle = ohlcData[i - 1];
                
                // Calculate candle properties
                const body = Math.abs(candle.c - candle.o);
                const upperShadow = candle.h - Math.max(candle.c, candle.o);
                const lowerShadow = Math.min(candle.c, candle.o) - candle.l;
                const totalRange = candle.h - candle.l;
                const isBullish = candle.c > candle.o;
                
                // More lenient thresholds for pattern detection
                const avgPrice = (candle.h + candle.l + candle.c + candle.o) / 4;
                const significantMove = avgPrice * 0.01; // 1% move is significant
                
                // 1. Doji pattern (small body relative to total range)
                if (totalRange > 0 && body < totalRange * 0.3 && totalRange > significantMove) {
                    patterns.push({
                        type: 'Doji',
                        signal: 'NEUTRAL',
                        strength: 'Medium',
                        reason: `Doji pattern shows market indecision (body: $${body.toFixed(2)}, range: $${totalRange.toFixed(2)})`,
                        timestamp: candle.x
                    });
                }
                
                // 2. Strong bullish/bearish candles
                if (body > totalRange * 0.6 && totalRange > significantMove) {
                    const patternType = isBullish ? 'Strong Bullish Candle' : 'Strong Bearish Candle';
                    const signal = isBullish ? 'BUY' : 'SELL';
                    patterns.push({
                        type: patternType,
                        signal: signal,
                        strength: 'Medium',
                        reason: `${patternType} with large body indicates strong ${isBullish ? 'buying' : 'selling'} pressure`,
                        timestamp: candle.x
                    });
                }
                
                // 3. Hammer-like patterns (longer lower shadow)
                if (totalRange > 0 && lowerShadow > body && lowerShadow > totalRange * 0.4) {
                    const patternName = 'Hammer-like';
                    patterns.push({
                        type: patternName,
                        signal: 'BUY',
                        strength: 'Medium',
                        reason: `${patternName} pattern with long lower shadow suggests potential support`,
                        timestamp: candle.x
                    });
                }
                
                // 4. Shooting Star-like patterns (longer upper shadow)
                if (totalRange > 0 && upperShadow > body && upperShadow > totalRange * 0.4) {
                    const patternName = 'Shooting Star-like';
                    patterns.push({
                        type: patternName,
                        signal: 'SELL',
                        strength: 'Medium',
                        reason: `${patternName} pattern with long upper shadow suggests potential resistance`,
                        timestamp: candle.x
                    });
                }
                
                // 5. Trend continuation patterns
                const prevBody = Math.abs(prevCandle.c - prevCandle.o);
                const prevIsBullish = prevCandle.c > prevCandle.o;
                
                // Two consecutive bullish candles
                if (isBullish && prevIsBullish && body > significantMove && prevBody > significantMove) {
                    patterns.push({
                        type: 'Bullish Continuation',
                        signal: 'BUY',
                        strength: 'Medium',
                        reason: 'Two consecutive bullish periods suggest upward momentum',
                        timestamp: candle.x
                    });
                }
                
                // Two consecutive bearish candles
                if (!isBullish && !prevIsBullish && body > significantMove && prevBody > significantMove) {
                    patterns.push({
                        type: 'Bearish Continuation',
                        signal: 'SELL',
                        strength: 'Medium',
                        reason: 'Two consecutive bearish periods suggest downward momentum',
                        timestamp: candle.x
                    });
                }
                
                // 6. Reversal patterns (direction change)
                if (prevIsBullish && !isBullish && body > prevBody * 0.8) {
                    patterns.push({
                        type: 'Bearish Reversal',
                        signal: 'SELL',
                        strength: 'Strong',
                        reason: 'Strong bearish candle after bullish period suggests trend reversal',
                        timestamp: candle.x
                    });
                }
                
                if (!prevIsBullish && isBullish && body > prevBody * 0.8) {
                    patterns.push({
                        type: 'Bullish Reversal',
                        signal: 'BUY',
                        strength: 'Strong',
                        reason: 'Strong bullish candle after bearish period suggests trend reversal',
                        timestamp: candle.x
                    });
                }
            }
            
            console.log(`üîç Found ${patterns.length} candlestick patterns:`, patterns.map(p => p.type));
            return patterns;
        }

        function analyzePriceMovementPatterns(priceData) {
            const patterns = [];
            
            if (priceData.length < 3) {
                console.log('üìä Insufficient price data for pattern analysis');
                return patterns;
            }
            
            console.log(`üîç Analyzing price movement patterns in ${priceData.length} data points...`);
            
            // Calculate price movements and trends
            const movements = [];
            for (let i = 1; i < priceData.length; i++) {
                const prevPrice = priceData[i - 1].y;
                const currentPrice = priceData[i].y;
                const change = currentPrice - prevPrice;
                const percentChange = (change / prevPrice) * 100;
                
                movements.push({
                    x: priceData[i].x,
                    price: currentPrice,
                    change: change,
                    percentChange: percentChange,
                    isPositive: change >= 0,
                    isSignificant: Math.abs(percentChange) > 1 // 1% change is significant
                });
            }
            
            // Look for consecutive patterns
            for (let i = 1; i < movements.length; i++) {
                const currentMove = movements[i];
                const prevMove = movements[i - 1];
                
                // Strong upward movement
                if (currentMove.percentChange > 2) {
                    patterns.push({
                        type: 'Strong Price Increase',
                        signal: 'BUY',
                        strength: 'Medium',
                        reason: `Strong upward movement of ${currentMove.percentChange.toFixed(2)}% suggests buying interest`,
                        timestamp: currentMove.x
                    });
                }
                
                // Strong downward movement
                if (currentMove.percentChange < -2) {
                    patterns.push({
                        type: 'Strong Price Decrease',
                        signal: 'SELL',
                        strength: 'Medium',
                        reason: `Strong downward movement of ${currentMove.percentChange.toFixed(2)}% suggests selling pressure`,
                        timestamp: currentMove.x
                    });
                }
                
                // Trend continuation (two consecutive moves in same direction)
                if (currentMove.isPositive && prevMove.isPositive && 
                    currentMove.isSignificant && prevMove.isSignificant) {
                    patterns.push({
                        type: 'Bullish Momentum',
                        signal: 'BUY',
                        strength: 'Medium',
                        reason: 'Two consecutive positive price movements suggest upward momentum',
                        timestamp: currentMove.x
                    });
                }
                
                if (!currentMove.isPositive && !prevMove.isPositive && 
                    currentMove.isSignificant && prevMove.isSignificant) {
                    patterns.push({
                        type: 'Bearish Momentum',
                        signal: 'SELL',
                        strength: 'Medium',
                        reason: 'Two consecutive negative price movements suggest downward momentum',
                        timestamp: currentMove.x
                    });
                }
                
                // Reversal patterns (direction change)
                if (prevMove.isPositive && !currentMove.isPositive && 
                    Math.abs(currentMove.percentChange) > Math.abs(prevMove.percentChange)) {
                    patterns.push({
                        type: 'Bearish Reversal',
                        signal: 'SELL',
                        strength: 'Strong',
                        reason: 'Strong negative movement after positive suggests trend reversal',
                        timestamp: currentMove.x
                    });
                }
                
                if (!prevMove.isPositive && currentMove.isPositive && 
                    Math.abs(currentMove.percentChange) > Math.abs(prevMove.percentChange)) {
                    patterns.push({
                        type: 'Bullish Reversal',
                        signal: 'BUY',
                        strength: 'Strong',
                        reason: 'Strong positive movement after negative suggests trend reversal',
                        timestamp: currentMove.x
                    });
                }
            }
            
            // Look for consolidation patterns (small movements)
            let consolidationCount = 0;
            for (let i = movements.length - 5; i < movements.length; i++) {
                if (i >= 0 && Math.abs(movements[i].percentChange) < 0.5) {
                    consolidationCount++;
                }
            }
            
            if (consolidationCount >= 3) {
                patterns.push({
                    type: 'Price Consolidation',
                    signal: 'NEUTRAL',
                    strength: 'Medium',
                    reason: `Recent price movements show consolidation with ${consolidationCount} small changes`,
                    timestamp: movements[movements.length - 1].x
                });
            }
            
            // Look for overall trend in recent movements
            const recentMovements = movements.slice(-5);
            const positiveCount = recentMovements.filter(m => m.isPositive).length;
            const negativeCount = recentMovements.filter(m => !m.isPositive).length;
            
            if (positiveCount >= 4) {
                patterns.push({
                    type: 'Strong Uptrend',
                    signal: 'BUY',
                    strength: 'Strong',
                    reason: `${positiveCount} out of ${recentMovements.length} recent movements are positive`,
                    timestamp: movements[movements.length - 1].x
                });
            } else if (negativeCount >= 4) {
                patterns.push({
                    type: 'Strong Downtrend',
                    signal: 'SELL',
                    strength: 'Strong',
                    reason: `${negativeCount} out of ${recentMovements.length} recent movements are negative`,
                    timestamp: movements[movements.length - 1].x
                });
            }
            
            console.log(`üîç Found ${patterns.length} price movement patterns:`, patterns.map(p => p.type));
            return patterns;
        }

        function calculateOverallSignal(signals) {
            console.log('üìä Calculating overall signal from signals:', signals.map(s => `${s.type}: ${s.signal} (${s.strength})`));
            
            let buyCount = 0;
            let sellCount = 0;
            let neutralCount = 0;
            let totalActionableStrength = 0; // Only BUY/SELL signals
            let totalStrength = 0; // All signals including NEUTRAL

            signals.forEach(signal => {
                const strengthValue = signal.strength === 'Strong' ? 3 : signal.strength === 'Medium' ? 2 : 1;
                totalStrength += strengthValue;

                if (signal.signal === 'BUY') {
                    buyCount += strengthValue;
                    totalActionableStrength += strengthValue;
                } else if (signal.signal === 'SELL') {
                    sellCount += strengthValue;
                    totalActionableStrength += strengthValue;
                } else if (signal.signal === 'NEUTRAL') {
                    neutralCount += strengthValue;
                }
            });

            // Calculate percentages based on actionable signals only (ignore NEUTRAL for thresholds)
            let buyPercentage = 0;
            let sellPercentage = 0;
            let confidence = 50;
            
            if (totalActionableStrength > 0) {
                buyPercentage = (buyCount / totalActionableStrength) * 100;
                sellPercentage = (sellCount / totalActionableStrength) * 100;
            }
            
            // Enhanced decision logic with lower thresholds and RSI override
            let signal;
            
            // Special case: Strong RSI signal (oversold/overbought) can override other signals
            const rsiSignal = signals.find(s => s.type === 'RSI');
            if (rsiSignal && rsiSignal.strength === 'Strong') {
                if (rsiSignal.signal === 'BUY' && buyCount >= sellCount) {
                    signal = 'BUY';
                    confidence = Math.min(85, 65 + (buyCount - sellCount) * 5);
                } else if (rsiSignal.signal === 'SELL' && sellCount >= buyCount) {
                    signal = 'SELL';
                    confidence = Math.min(85, 65 + (sellCount - buyCount) * 5);
                } else {
                    // RSI signal conflicts with other indicators
                    signal = 'HOLD';
                    confidence = 55;
                }
            } else {
                // Normal logic with reduced thresholds
                if (buyPercentage >= 45) { // Reduced from 60% to 45%
                    signal = 'BUY';
                    confidence = Math.min(90, 50 + buyPercentage * 0.6);
                } else if (sellPercentage >= 45) { // Reduced from 60% to 45%
                    signal = 'SELL';
                    confidence = Math.min(90, 50 + sellPercentage * 0.6);
                } else {
                    signal = 'HOLD';
                    confidence = Math.max(45, 60 - Math.abs(buyPercentage - sellPercentage));
                }
            }
            
            const result = {
                signal: signal,
                confidence: Math.round(confidence),
                buyCount: buyCount,
                sellCount: sellCount,
                neutralCount: neutralCount,
                buyPercentage: buyPercentage.toFixed(1),
                sellPercentage: sellPercentage.toFixed(1)
            };
            
            console.log('üìä Overall signal calculation:', result);
            return result;
        }

        async function fetchPriceData(coinId, days) {
            try {
                console.log(`Fetching price data for ${coinId} over ${days} days...`);
                const response = await fetch(`${WORKER_URL}/history?coin=${coinId}&days=${days}`);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const data = await response.json();
                console.log(`Received ${data.prices.length} price points`);
                
                const priceData = data.prices.map(item => ({
                    x: new Date(item.timestamp),
                    y: item.price
                }));
                
                // Flexible data requirements - adapt indicators to available data
                if (priceData.length < 3) {
                    throw new Error(`Insufficient data: only ${priceData.length} points available (need at least 3 for basic analysis)`);
                }
                
                console.log(`‚úÖ Price data ready: ${priceData.length} points over ${days} days`);
                return priceData;
            } catch (error) {
                console.error('Error fetching price data:', error);
                throw error;
            }
        }

        async function fetchOHLCData(coinId, days) {
            try {
                console.log(`Fetching OHLC data for ${coinId} over ${days} days...`);
                
                // First try to get OHLC data from a dedicated endpoint
                try {
                    const response = await fetch(`${WORKER_URL}/ohlc?coin=${coinId}&days=${days}`);
                    if (response.ok) {
                        const data = await response.json();
                        console.log(`Received ${data.ohlc.length} OHLC points`);
                        
                        const ohlcData = data.ohlc.map(item => ({
                            x: new Date(item.timestamp),
                            o: item.open,
                            h: item.high,
                            l: item.low,
                            c: item.close
                        }));
                        
                        return ohlcData;
                    }
                } catch (ohlcError) {
                    console.log('OHLC endpoint not available, using price data to simulate OHLC...');
                }
                
                // Fallback: Convert price data to simulated OHLC
                const priceData = await fetchPriceData(coinId, days);
                const ohlcData = [];
                
                // Create reasonable number of candlesticks (aim for 20-30 candles)
                const targetCandles = Math.min(30, Math.max(15, Math.floor(days * 0.8)));
                const periodSize = Math.max(1, Math.floor(priceData.length / targetCandles));
                
                console.log(`Creating ${targetCandles} target candles with period size ${periodSize} from ${priceData.length} price points`);
                
                for (let i = 0; i < priceData.length; i += periodSize) {
                    const periodData = priceData.slice(i, Math.min(i + periodSize, priceData.length));
                    if (periodData.length === 0) continue;
                    
                    const open = periodData[0].y;
                    const close = periodData[periodData.length - 1].y;
                    const high = Math.max(...periodData.map(p => p.y));
                    const low = Math.min(...periodData.map(p => p.y));
                    
                    // Ensure meaningful OHLC differences for pattern detection
                    const priceRange = high - low;
                    const bodySize = Math.abs(close - open);
                    
                    // Only include periods with meaningful price movement
                    if (priceRange > 0 && (bodySize > priceRange * 0.05 || priceRange > open * 0.001)) {
                        const candle = {
                            x: periodData[Math.floor(periodData.length / 2)].x, // Use middle timestamp
                            o: parseFloat(open.toFixed(2)),
                            h: parseFloat(high.toFixed(2)),
                            l: parseFloat(low.toFixed(2)),
                            c: parseFloat(close.toFixed(2)),
                            // Add volume simulation
                            v: Math.random() * 1000000 + 500000
                        };
                        ohlcData.push(candle);
                        
                        // Enhanced debug logging
                        if (ohlcData.length <= 5) {
                            console.log(`Candle ${ohlcData.length}:`, {
                                date: candle.x.toLocaleDateString(),
                                open: candle.o,
                                high: candle.h,
                                low: candle.l,
                                close: candle.c,
                                direction: candle.c >= candle.o ? 'BULLISH ‚¨ÜÔ∏è' : 'BEARISH ‚¨áÔ∏è',
                                bodySize: Math.abs(candle.c - candle.o).toFixed(2),
                                priceRange: priceRange.toFixed(2)
                            });
                        }
                    } else {
                        console.log(`Skipping period with insufficient movement: range=${priceRange.toFixed(2)}, body=${bodySize.toFixed(2)}`);
                    }
                }
                
                console.log(`Generated ${ohlcData.length} valid OHLC candles from price data`);
                return ohlcData;
                
            } catch (error) {
                console.error('Error fetching OHLC data:', error);
                throw error;
            }
        }

        function displayChart(price, sma20, bb, smaPeriod = 20) {
            console.log('Creating chart with data:', {
                pricePoints: price.length,
                smaPoints: sma20.length,
                bbUpperPoints: bb.upper.length,
                bbLowerPoints: bb.lower.length,
                smaPeriod: smaPeriod
            });
            
            const canvas = document.getElementById('taChart');
            const ctx = canvas.getContext('2d');
            
            // Reset canvas visibility
            canvas.style.display = 'none';
            canvas.classList.remove('visible');
            
            // ‚úÖ CHART FIX: Properly destroy existing chart to prevent memory leaks
            if (chartInstance) {
                // Unregister from responsive manager
                if (window.taChartManager) {
                    window.taChartManager.unregisterChart('taChart');
                }
                chartInstance.destroy();
                chartInstance = null;
            }

            // üõ†Ô∏è FIX: Enhanced theme-aware colors with better contrast
            const isDark = document.body.classList.contains('dark-theme');
            const priceColor = getComputedStyle(document.documentElement).getPropertyValue('--accent-color').trim() || '#3B82F6';
            const successColor = getComputedStyle(document.documentElement).getPropertyValue('--success-color').trim() || '#10B981';
            const dangerColor = getComputedStyle(document.documentElement).getPropertyValue('--danger-color').trim() || '#EF4444';
            const warningColor = getComputedStyle(document.documentElement).getPropertyValue('--warning-color').trim() || '#F59E0B';
            
            // üõ†Ô∏è FIX: Better contrast colors for both light and dark themes
            const textColor = isDark ? '#ffffff' : '#1a202c';
            const gridColor = isDark ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.1)';
            const backgroundColor = isDark ? 'rgba(30, 41, 59, 0.8)' : 'rgba(255, 255, 255, 0.95)';
            const borderColor = isDark ? 'rgba(255, 255, 255, 0.2)' : 'rgba(0, 0, 0, 0.1)';
            
            console.log('üé® Theme colors applied:', { isDark, textColor, gridColor, backgroundColor });

            // Prepare datasets for chart
            const datasets = [
                {
                    label: 'Price',
                    data: price,
                    borderColor: priceColor,
                    backgroundColor: priceColor + '20',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.1,
                    pointRadius: 1,
                    pointHoverRadius: 5,
                    order: 1
                }
            ];

            // Add SMA if available
            if (sma20.length > 0) {
                datasets.push({
                    label: `SMA ${smaPeriod} (${sma20.length} points)`,
                    data: sma20,
                    borderColor: successColor,
                    borderWidth: 2,
                    fill: false,
                    pointRadius: 0,
                    pointHoverRadius: 3,
                    order: 2
                });
            }

            // Add Bollinger Bands if available
            if (bb.upper.length > 0 && bb.lower.length > 0) {
                datasets.push(
                    {
                        label: `BB Upper (${bb.upper.length} points)`,
                        data: bb.upper,
                        borderColor: dangerColor,
                        borderWidth: 1,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0,
                        order: 3
                    },
                    {
                        label: `BB Lower (${bb.lower.length} points)`,
                        data: bb.lower,
                        borderColor: dangerColor,
                        borderWidth: 1,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0,
                        order: 4
                    }
                );
            }

            console.log('Chart datasets prepared:', datasets.map(d => ({ label: d.label, dataPoints: d.data.length })));

            // üõ†Ô∏è FIX: Enhanced Chart.js configuration with improved theme consistency
            chartInstance = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    resizeDelay: 100,
                    devicePixelRatio: window.devicePixelRatio || 1,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: { unit: 'day' },
                            ticks: {
                                maxTicksLimit: window.innerWidth < 768 ? 4 : 7,
                                font: {
                                    size: window.innerWidth < 768 ? 10 : 11,
                                    weight: '500',
                                    family: 'system-ui, -apple-system, sans-serif'
                                },
                                color: textColor,
                                padding: 2
                            },
                            grid: {
                                color: gridColor,
                                lineWidth: 1
                            },
                            border: {
                                color: borderColor,
                                width: 1
                            },
                            title: {
                                display: true,
                                text: 'Date',
                                color: textColor,
                                font: {
                                    size: window.innerWidth < 768 ? 11 : 12,
                                    weight: '600',
                                    family: 'system-ui, -apple-system, sans-serif'
                                },
                                padding: { top: 2, bottom: 2 }
                            }
                        },
                        y: {
                            beginAtZero: false,
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toLocaleString();
                                },
                                font: {
                                    size: window.innerWidth < 768 ? 10 : 11,
                                    weight: '500',
                                    family: 'system-ui, -apple-system, sans-serif'
                                },
                                color: textColor,
                                padding: 2
                            },
                            grid: {
                                color: gridColor,
                                lineWidth: 1
                            },
                            border: {
                                color: borderColor,
                                width: 1
                            },
                            title: {
                                display: true,
                                text: 'Price (USD)',
                                color: textColor,
                                font: {
                                    size: window.innerWidth < 768 ? 11 : 12,
                                    weight: '600',
                                    family: 'system-ui, -apple-system, sans-serif'
                                },
                                padding: { top: 2, bottom: 2 }
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'üìà Technical Analysis Chart',
                            font: { 
                                size: window.innerWidth < 768 ? 13 : 15,
                                weight: 'bold',
                                family: 'system-ui, -apple-system, sans-serif'
                            },
                            color: textColor,
                            padding: { top: 4, bottom: 6 }
                        },
                        legend: {
                            display: true,
                            position: window.innerWidth < 768 ? 'bottom' : 'top',
                            labels: {
                                font: {
                                    size: window.innerWidth < 768 ? 10 : 11,
                                    weight: '500',
                                    family: 'system-ui, -apple-system, sans-serif'
                                },
                                padding: 8,
                                usePointStyle: true,
                                boxWidth: window.innerWidth < 768 ? 8 : 10,
                                color: textColor
                            }
                        },
                        subtitle: {
                            display: window.innerWidth >= 768,
                            text: 'üìù Note: Technical indicators start after sufficient data points are collected for accurate calculation',
                            font: { 
                                size: 10,
                                style: 'italic',
                                weight: '400',
                                family: 'system-ui, -apple-system, sans-serif'
                            },
                            color: textColor,
                            padding: { top: 2, bottom: 6 }
                        },
                        tooltip: {
                            backgroundColor: backgroundColor,
                            titleColor: textColor,
                            bodyColor: textColor,
                            borderColor: borderColor,
                            borderWidth: 1,
                            cornerRadius: 6,
                            titleFont: { 
                                size: window.innerWidth < 768 ? 11 : 12,
                                weight: '600',
                                family: 'system-ui, -apple-system, sans-serif'
                            },
                            bodyFont: { 
                                size: window.innerWidth < 768 ? 10 : 11,
                                weight: '500',
                                family: 'system-ui, -apple-system, sans-serif'
                            },
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += '$' + context.parsed.y.toLocaleString();
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    layout: {
                        padding: { top: 2, bottom: 2, left: 2, right: 2 }
                    },
                    animation: {
                        duration: window.innerWidth < 768 ? 100 : 200,
                        easing: 'easeInOutQuart'
                    },
                    elements: {
                        point: {
                            radius: window.innerWidth < 768 ? 1 : 2,
                            hoverRadius: window.innerWidth < 768 ? 3 : 4,
                            borderWidth: window.innerWidth < 768 ? 1 : 1
                        },
                        line: {
                            tension: 0.1,
                            borderWidth: window.innerWidth < 768 ? 1 : 2
                        }
                    }
                }
            });

            // üîß FIXED: Reliable chart display with proper timing
            setTimeout(() => {
                const canvas = document.getElementById('taChart');
                
                // Simple, reliable canvas visibility
                canvas.style.display = 'block';
                canvas.style.visibility = 'visible';
                canvas.style.opacity = '1';
                canvas.classList.add('visible');
                
                // Ensure chart renders properly
                if (chartInstance) {
                    chartInstance.update();
                    chartInstance.resize();
                    
                    // Register chart with responsive manager
                    if (window.taChartManager) {
                        window.taChartManager.registerChart('taChart', chartInstance);
                    }
                    
                    // Final render after a short delay
                    setTimeout(() => {
                        chartInstance.render();
                        console.log('‚úÖ Chart successfully rendered:', {
                            canvasWidth: canvas.clientWidth,
                            canvasHeight: canvas.clientHeight,
                            hasChart: !!chartInstance,
                            datasetsCount: chartInstance.data.datasets.length
                        });
                    }, 50);
                }
            }, 100);
        }

                function displayCandlestickChart(ohlcData, coinId) {
            console.log('Creating OHLC visualization with data:', {
                candlePoints: ohlcData.length
            });
            
            // Validate OHLC data
            if (!ohlcData || ohlcData.length === 0) {
                console.error('No OHLC data available for candlestick chart');
                document.getElementById('candleError').style.display = 'block';
                document.getElementById('candleError').innerHTML = '<strong>‚ö†Ô∏è No Data:</strong> Unable to generate candlestick chart - insufficient price data.';
                return;
            }
            
            const canvas = document.getElementById('candleChart');
            const ctx = canvas.getContext('2d');
            
            // Reset canvas visibility
            canvas.style.display = 'none';
            canvas.classList.remove('visible');
            
            // Destroy existing chart to prevent memory leaks
            if (candleChartInstance) {
                // Unregister from responsive manager
                if (window.taChartManager) {
                    window.taChartManager.unregisterChart('candleChart');
                }
                candleChartInstance.destroy();
                candleChartInstance = null;
            }

            // Get theme-aware colors
            const isDark = document.body.classList.contains('dark-theme');
            const textColor = isDark ? '#ffffff' : '#1a202c';
            const gridColor = isDark ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.1)';
            const backgroundColor = isDark ? 'rgba(30, 41, 59, 0.8)' : 'rgba(255, 255, 255, 0.95)';
            const borderColor = isDark ? 'rgba(255, 255, 255, 0.2)' : 'rgba(0, 0, 0, 0.1)';
            
            console.log('üé® OHLC chart theme colors applied:', { isDark, textColor, gridColor, backgroundColor });

            // Create improved OHLC visualization using multiple datasets
            const datasets = [];
            
            // Split data into bullish and bearish periods
            const bullishCandles = ohlcData.filter(candle => candle.c > candle.o);
            const bearishCandles = ohlcData.filter(candle => candle.c < candle.o);
            const dojiCandles = ohlcData.filter(candle => Math.abs(candle.c - candle.o) < (candle.h - candle.l) * 0.1);
            
            console.log(`üìä OHLC Analysis: ${bullishCandles.length} bullish, ${bearishCandles.length} bearish, ${dojiCandles.length} doji periods`);
            
            // 1. Bullish periods (close > open) - Green bars
            if (bullishCandles.length > 0) {
                datasets.push({
                    label: `Bullish Periods (${bullishCandles.length})`,
                    type: 'bar',
                    data: bullishCandles.map(candle => ({
                        x: candle.x,
                        y: candle.c
                    })),
                    backgroundColor: '#10B98160',
                    borderColor: '#10B981',
                    borderWidth: 2,
                    barThickness: 'flex',
                    maxBarThickness: 20,
                    order: 1
                });
            }
            
            // 2. Bearish periods (close < open) - Red bars  
            if (bearishCandles.length > 0) {
                datasets.push({
                    label: `Bearish Periods (${bearishCandles.length})`,
                    type: 'bar', 
                    data: bearishCandles.map(candle => ({
                        x: candle.x,
                        y: candle.c
                    })),
                    backgroundColor: '#EF444460',
                    borderColor: '#EF4444',
                    borderWidth: 2,
                    barThickness: 'flex',
                    maxBarThickness: 20,
                    order: 2
                });
            }
            
            // 3. High-Low wicks for all periods
            datasets.push({
                label: 'High-Low Wicks',
                type: 'scatter',
                data: ohlcData.flatMap(candle => [
                    { x: candle.x, y: candle.h },
                    { x: candle.x, y: candle.l }
                ]),
                borderColor: '#6B728050',
                backgroundColor: '#6B728050',
                pointRadius: 1,
                pointHoverRadius: 3,
                showLine: false,
                order: 4
            });
            
            // 4. Overall price trend line
            datasets.push({
                label: 'Price Trend',
                type: 'line',
                data: ohlcData.map(candle => ({
                    x: candle.x,
                    y: candle.c
                })),
                borderColor: '#3B82F6',
                backgroundColor: 'transparent',
                borderWidth: 2,
                pointRadius: 1,
                pointHoverRadius: 4,
                tension: 0.2,
                order: 0
            });

            candleChartInstance = new Chart(ctx, {
                type: 'bar',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    resizeDelay: 0,
                    devicePixelRatio: window.devicePixelRatio || 1,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: { unit: 'day' },
                            ticks: {
                                maxTicksLimit: window.innerWidth < 768 ? 4 : 7,
                                font: {
                                    size: window.innerWidth < 768 ? 10 : 11,
                                    weight: '500',
                                    family: 'system-ui, -apple-system, sans-serif'
                                },
                                color: textColor,
                                padding: 2
                            },
                            grid: {
                                color: gridColor,
                                lineWidth: 1
                            },
                            border: {
                                color: borderColor,
                                width: 1
                            },
                            title: {
                                display: true,
                                text: 'Date',
                                color: textColor,
                                font: {
                                    size: window.innerWidth < 768 ? 11 : 12,
                                    weight: '600',
                                    family: 'system-ui, -apple-system, sans-serif'
                                },
                                padding: { top: 2, bottom: 2 }
                            }
                        },
                        y: {
                            beginAtZero: false,
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toLocaleString();
                                },
                                font: {
                                    size: window.innerWidth < 768 ? 10 : 11,
                                    weight: '500',
                                    family: 'system-ui, -apple-system, sans-serif'
                                },
                                color: textColor,
                                padding: 2
                            },
                            grid: {
                                color: gridColor,
                                lineWidth: 1
                            },
                            border: {
                                color: borderColor,
                                width: 1
                            },
                            title: {
                                display: true,
                                text: 'Price (USD)',
                                color: textColor,
                                font: {
                                    size: window.innerWidth < 768 ? 11 : 12,
                                    weight: '600',
                                    family: 'system-ui, -apple-system, sans-serif'
                                },
                                padding: { top: 2, bottom: 2 }
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'üïØÔ∏è OHLC Price Analysis',
                            font: { 
                                size: window.innerWidth < 768 ? 13 : 15,
                                weight: 'bold',
                                family: 'system-ui, -apple-system, sans-serif'
                            },
                            color: textColor,
                            padding: { top: 4, bottom: 6 }
                        },
                        legend: {
                            display: true,
                            position: window.innerWidth < 768 ? 'bottom' : 'top',
                            labels: {
                                font: {
                                    size: window.innerWidth < 768 ? 10 : 11,
                                    weight: '500',
                                    family: 'system-ui, -apple-system, sans-serif'
                                },
                                padding: 8,
                                usePointStyle: true,
                                boxWidth: window.innerWidth < 768 ? 8 : 10,
                                color: textColor,
                                filter: function(legendItem) {
                                    // Hide High-Low Wicks from legend to reduce clutter
                                    return !['High-Low Wicks'].includes(legendItem.text);
                                }
                            }
                        },
                        subtitle: {
                            display: window.innerWidth >= 768,
                            text: 'üìù Green bars = price increased, Red bars = price decreased, Blue line = price trend',
                            font: { 
                                size: 10,
                                style: 'italic',
                                weight: '400',
                                family: 'system-ui, -apple-system, sans-serif'
                            },
                            color: textColor,
                            padding: { top: 2, bottom: 6 }
                        },
                        tooltip: {
                            backgroundColor: backgroundColor,
                            titleColor: textColor,
                            bodyColor: textColor,
                            borderColor: borderColor,
                            borderWidth: 1,
                            cornerRadius: 6,
                            titleFont: { 
                                size: window.innerWidth < 768 ? 11 : 12,
                                weight: '600',
                                family: 'system-ui, -apple-system, sans-serif'
                            },
                            bodyFont: { 
                                size: window.innerWidth < 768 ? 10 : 11,
                                weight: '500',
                                family: 'system-ui, -apple-system, sans-serif'
                            },
                            callbacks: {
                                title: function(context) {
                                    return context[0].label; // Show the date
                                },
                                beforeBody: function(context) {
                                    // Find the corresponding OHLC data for this time point
                                    const timePoint = context[0].parsed.x;
                                    const candle = ohlcData.find(c => c.x.getTime() === new Date(timePoint).getTime());
                                    
                                    if (candle) {
                                        const priceChange = candle.c - candle.o;
                                        const percentChange = ((priceChange / candle.o) * 100).toFixed(2);
                                        const direction = candle.c >= candle.o ? 'üìà' : 'üìâ';
                                        
                                        return [
                                            `${direction} OHLC Data:`,
                                            `Open: $${candle.o.toLocaleString()}`,
                                            `High: $${candle.h.toLocaleString()}`,
                                            `Low: $${candle.l.toLocaleString()}`,
                                            `Close: $${candle.c.toLocaleString()}`,
                                            `Change: ${priceChange >= 0 ? '+' : ''}$${priceChange.toFixed(2)} (${percentChange}%)`,
                                            `Range: $${(candle.h - candle.l).toFixed(2)}`
                                        ];
                                    }
                                    return ['No OHLC data available'];
                                },
                                label: function(context) {
                                    // Show the dataset name and value
                                    const label = context.dataset.label || '';
                                    const value = context.parsed.y;
                                    return `${label}: $${value.toLocaleString()}`;
                                }
                            }
                        }
                    },
                    layout: {
                        padding: { top: 2, bottom: 2, left: 2, right: 2 }
                    },
                    animation: {
                        duration: window.innerWidth < 768 ? 100 : 200,
                        easing: 'easeInOutQuart'
                    }
                }
            });

            // Reliable chart display with proper timing
            setTimeout(() => {
                const canvas = document.getElementById('candleChart');
                
                // Simple, reliable canvas visibility
                canvas.style.display = 'block';
                canvas.style.visibility = 'visible';
                canvas.style.opacity = '1';
                canvas.classList.add('visible');
                
                // Ensure chart renders properly
                if (candleChartInstance) {
                    candleChartInstance.update();
                    candleChartInstance.resize();
                    
                    // Register chart with responsive manager
                    if (window.taChartManager) {
                        window.taChartManager.registerChart('candleChart', candleChartInstance);
                    }
                    
                    // Final render after a short delay
                    setTimeout(() => {
                        candleChartInstance.render();
                        console.log('‚úÖ OHLC chart successfully rendered:', {
                            canvasWidth: canvas.clientWidth,
                            canvasHeight: canvas.clientHeight,
                            hasChart: !!candleChartInstance,
                            totalCandles: ohlcData.length,
                            bullishCandles: bullishCandles.length,
                            bearishCandles: bearishCandles.length,
                            dojiCandles: dojiCandles.length,
                            datasetsCreated: datasets.length
                        });
                    }, 50);
                }
            }, 100);
        }

        function displayPriceBasedOHLC(priceData, coinId) {
            console.log('Creating price-based OHLC visualization with data:', {
                pricePoints: priceData.length
            });
            
            const canvas = document.getElementById('candleChart');
            const ctx = canvas.getContext('2d');
            
            // Reset canvas visibility
            canvas.style.display = 'none';
            canvas.classList.remove('visible');
            
            // Destroy existing chart to prevent memory leaks
            if (candleChartInstance) {
                // Unregister from responsive manager
                if (window.taChartManager) {
                    window.taChartManager.unregisterChart('candleChart');
                }
                candleChartInstance.destroy();
                candleChartInstance = null;
            }

            // Get theme-aware colors
            const isDark = document.body.classList.contains('dark-theme');
            const textColor = isDark ? '#ffffff' : '#1a202c';
            const gridColor = isDark ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.1)';
            const backgroundColor = isDark ? 'rgba(30, 41, 59, 0.8)' : 'rgba(255, 255, 255, 0.95)';
            const borderColor = isDark ? 'rgba(255, 255, 255, 0.2)' : 'rgba(0, 0, 0, 0.1)';
            
            // Create price movement visualization
            const datasets = [];
            
            // Calculate price changes between consecutive points
            const priceChanges = [];
            for (let i = 1; i < priceData.length; i++) {
                const prevPrice = priceData[i - 1].y;
                const currentPrice = priceData[i].y;
                const change = currentPrice - prevPrice;
                
                priceChanges.push({
                    x: priceData[i].x,
                    y: currentPrice,
                    change: change,
                    isPositive: change >= 0,
                    percentChange: (change / prevPrice) * 100
                });
            }
            
            // Split into positive and negative movements
            const positiveChanges = priceChanges.filter(p => p.isPositive);
            const negativeChanges = priceChanges.filter(p => !p.isPositive);
            
            console.log(`üìä Price Analysis: ${positiveChanges.length} positive movements, ${negativeChanges.length} negative movements`);
            
            // Positive price movements (green bars)
            if (positiveChanges.length > 0) {
                datasets.push({
                    label: `Price Increases (${positiveChanges.length})`,
                    type: 'bar',
                    data: positiveChanges.map(p => ({
                        x: p.x,
                        y: p.y
                    })),
                    backgroundColor: '#10B98160',
                    borderColor: '#10B981',
                    borderWidth: 2,
                    barThickness: 'flex',
                    maxBarThickness: 25,
                    order: 1
                });
            }
            
            // Negative price movements (red bars)
            if (negativeChanges.length > 0) {
                datasets.push({
                    label: `Price Decreases (${negativeChanges.length})`,
                    type: 'bar',
                    data: negativeChanges.map(p => ({
                        x: p.x,
                        y: p.y
                    })),
                    backgroundColor: '#EF444460',
                    borderColor: '#EF4444',
                    borderWidth: 2,
                    barThickness: 'flex',
                    maxBarThickness: 25,
                    order: 2
                });
            }
            
            // Overall price trend line
            datasets.push({
                label: 'Price Trend',
                type: 'line',
                data: priceData,
                borderColor: '#3B82F6',
                backgroundColor: 'transparent',
                borderWidth: 2,
                pointRadius: 2,
                pointHoverRadius: 5,
                tension: 0.2,
                order: 0
            });

            candleChartInstance = new Chart(ctx, {
                type: 'bar',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    resizeDelay: 0,
                    devicePixelRatio: window.devicePixelRatio || 1,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: { unit: 'day' },
                            ticks: {
                                maxTicksLimit: window.innerWidth < 768 ? 4 : 7,
                                font: {
                                    size: window.innerWidth < 768 ? 10 : 11,
                                    weight: '500',
                                    family: 'system-ui, -apple-system, sans-serif'
                                },
                                color: textColor,
                                padding: 2
                            },
                            grid: {
                                color: gridColor,
                                lineWidth: 1
                            },
                            border: {
                                color: borderColor,
                                width: 1
                            },
                            title: {
                                display: true,
                                text: 'Date',
                                color: textColor,
                                font: {
                                    size: window.innerWidth < 768 ? 11 : 12,
                                    weight: '600',
                                    family: 'system-ui, -apple-system, sans-serif'
                                },
                                padding: { top: 2, bottom: 2 }
                            }
                        },
                        y: {
                            beginAtZero: false,
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toLocaleString();
                                },
                                font: {
                                    size: window.innerWidth < 768 ? 10 : 11,
                                    weight: '500',
                                    family: 'system-ui, -apple-system, sans-serif'
                                },
                                color: textColor,
                                padding: 2
                            },
                            grid: {
                                color: gridColor,
                                lineWidth: 1
                            },
                            border: {
                                color: borderColor,
                                width: 1
                            },
                            title: {
                                display: true,
                                text: 'Price (USD)',
                                color: textColor,
                                font: {
                                    size: window.innerWidth < 768 ? 11 : 12,
                                    weight: '600',
                                    family: 'system-ui, -apple-system, sans-serif'
                                },
                                padding: { top: 2, bottom: 2 }
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'üìä Price Movement Analysis',
                            font: { 
                                size: window.innerWidth < 768 ? 13 : 15,
                                weight: 'bold',
                                family: 'system-ui, -apple-system, sans-serif'
                            },
                            color: textColor,
                            padding: { top: 4, bottom: 6 }
                        },
                        legend: {
                            display: true,
                            position: window.innerWidth < 768 ? 'bottom' : 'top',
                            labels: {
                                font: {
                                    size: window.innerWidth < 768 ? 10 : 11,
                                    weight: '500',
                                    family: 'system-ui, -apple-system, sans-serif'
                                },
                                padding: 8,
                                usePointStyle: true,
                                boxWidth: window.innerWidth < 768 ? 8 : 10,
                                color: textColor
                            }
                        },
                        subtitle: {
                            display: window.innerWidth >= 768,
                            text: 'üìù Green bars = price increased from previous point, Red bars = price decreased',
                            font: { 
                                size: 10,
                                style: 'italic',
                                weight: '400',
                                family: 'system-ui, -apple-system, sans-serif'
                            },
                            color: textColor,
                            padding: { top: 2, bottom: 6 }
                        },
                        tooltip: {
                            backgroundColor: backgroundColor,
                            titleColor: textColor,
                            bodyColor: textColor,
                            borderColor: borderColor,
                            borderWidth: 1,
                            cornerRadius: 6,
                            titleFont: { 
                                size: window.innerWidth < 768 ? 11 : 12,
                                weight: '600',
                                family: 'system-ui, -apple-system, sans-serif'
                            },
                            bodyFont: { 
                                size: window.innerWidth < 768 ? 10 : 11,
                                weight: '500',
                                family: 'system-ui, -apple-system, sans-serif'
                            },
                            callbacks: {
                                title: function(context) {
                                    return context[0].label;
                                },
                                beforeBody: function(context) {
                                    const timePoint = context[0].parsed.x;
                                    const movement = priceChanges.find(p => p.x.getTime() === new Date(timePoint).getTime());
                                    
                                    if (movement) {
                                        const direction = movement.isPositive ? 'üìà' : 'üìâ';
                                        const changeText = movement.isPositive ? 'Increased' : 'Decreased';
                                        
                                        return [
                                            `${direction} Price ${changeText}:`,
                                            `Current: $${movement.y.toLocaleString()}`,
                                            `Change: ${movement.change >= 0 ? '+' : ''}$${movement.change.toFixed(2)}`,
                                            `Percent: ${movement.change >= 0 ? '+' : ''}${movement.percentChange.toFixed(2)}%`
                                        ];
                                    }
                                    return ['Price point'];
                                },
                                label: function(context) {
                                    const label = context.dataset.label || '';
                                    const value = context.parsed.y;
                                    return `${label}: $${value.toLocaleString()}`;
                                }
                            }
                        }
                    },
                    layout: {
                        padding: { top: 2, bottom: 2, left: 2, right: 2 }
                    },
                    animation: {
                        duration: window.innerWidth < 768 ? 100 : 200,
                        easing: 'easeInOutQuart'
                    }
                }
            });

            // Reliable chart display with proper timing
            setTimeout(() => {
                const canvas = document.getElementById('candleChart');
                
                canvas.style.display = 'block';
                canvas.style.visibility = 'visible';
                canvas.style.opacity = '1';
                canvas.classList.add('visible');
                
                if (candleChartInstance) {
                    candleChartInstance.update();
                    candleChartInstance.resize();
                    
                    // Register chart with responsive manager
                    if (window.taChartManager) {
                        window.taChartManager.registerChart('candleChart', candleChartInstance);
                    }
                    
                    setTimeout(() => {
                        candleChartInstance.render();
                        console.log('‚úÖ Price-based OHLC chart successfully rendered:', {
                            canvasWidth: canvas.clientWidth,
                            canvasHeight: canvas.clientHeight,
                            hasChart: !!candleChartInstance,
                            totalPricePoints: priceData.length,
                            positiveMovements: positiveChanges.length,
                            negativeMovements: negativeChanges.length,
                            datasetsCreated: datasets.length
                        });
                    }, 50);
                }
            }, 100);
        }

        function displayIndicators(rsi, sma20, signals, smaPeriod = 20, rsiPeriod = 14, bbPeriod = 20) {
            // ‚úÖ FIX: Robust RSI value extraction with proper fallbacks
            const currentRSI = rsi.length > 0 ? rsi[rsi.length - 1].y : null;
            const rsiDisplay = currentRSI !== null ? currentRSI.toFixed(2) : 'N/A';
            const rsiStatus = currentRSI !== null ? 'Available' : `Insufficient data (needs ${rsiPeriod}+ points)`;

            const rsiSignal = signals.find(s => s.type === 'RSI');
            const smaSignal = signals.find(s => s.type === 'SMA');
            const bbSignal = signals.find(s => s.type === 'BB');

            // ‚úÖ FIX: Enhanced display with data validation
            document.getElementById('indicators').innerHTML = `
                <div class="indicator">
                    <h3>üìà RSI (${rsiPeriod})</h3>
                    <div class="indicator-value">${rsiDisplay}</div>
                    <div class="signal ${rsiSignal.signal.toLowerCase()}">${rsiSignal.signal}</div>
                    <div class="signal-strength">${rsiSignal.strength} Signal</div>
                    <div class="explanation">${rsiSignal.reason}</div>
                    ${currentRSI === null ? `<div style="font-size: 0.8em; color: var(--warning-color); margin-top: 5px;">‚ö†Ô∏è ${rsiStatus}</div>` : ''}
                </div>

                <div class="indicator">
                    <h3>üìä Moving Average (${smaPeriod})</h3>
                    <div class="signal ${smaSignal.signal.toLowerCase()}">${smaSignal.signal}</div>
                    <div class="signal-strength">${smaSignal.strength} Signal</div>
                    <div class="explanation">${smaSignal.reason}</div>
                </div>

                <div class="indicator">
                    <h3>üìè Bollinger Bands (${bbPeriod})</h3>
                    <div class="signal ${bbSignal.signal.toLowerCase()}">${bbSignal.signal}</div>
                    <div class="signal-strength">${bbSignal.strength} Signal</div>
                    <div class="explanation">${bbSignal.reason}</div>
                </div>

                <div class="educational-notes">
                    <strong>üìö Educational Notes:</strong><br>
                    ‚Ä¢ <strong>Adaptive Indicators:</strong> Period lengths automatically adjust based on available data<br>
                    ‚Ä¢ <strong>RSI(${rsiPeriod}) interpretation:</strong> < 30 potentially oversold, > 70 potentially overbought<br>
                    ‚Ä¢ <strong>SMA(${smaPeriod}) signals:</strong> Price above SMA suggests potential uptrend<br>
                    ‚Ä¢ <strong>Bollinger Bands(${bbPeriod}):</strong> Price touching bands may indicate reversal opportunities<br>
                    ‚Ä¢ <strong>Technical accuracy:</strong> Shorter periods used when limited data available
                </div>
            `;
        }

        function displayIndicatorsWithPatterns(rsi, sma20, traditionalSignals, candlePatterns, smaPeriod = 20, rsiPeriod = 14, bbPeriod = 20, dataLength = 0) {
            // Traditional indicators
            const currentRSI = rsi.length > 0 ? rsi[rsi.length - 1].y : null;
            const rsiDisplay = currentRSI !== null ? currentRSI.toFixed(2) : 'N/A';
            const rsiStatus = currentRSI !== null ? 'Available' : `Insufficient data (needs ${rsiPeriod}+ points)`;

            const rsiSignal = traditionalSignals.find(s => s.type === 'RSI');
            const smaSignal = traditionalSignals.find(s => s.type === 'SMA');
            const bbSignal = traditionalSignals.find(s => s.type === 'BB');

            // Price patterns section (candlestick or price movement patterns)
            let patternsHTML = '';
            const patternTitle = candlePatterns.some(p => p.type.includes('Price')) ? 
                'üìä Price Movement Patterns' : 'üïØÔ∏è Candlestick Patterns';
            
            if (candlePatterns.length > 0) {
                patternsHTML = `
                    <div class="indicator patterns-container">
                        <h3>${patternTitle}</h3>
                        <div style="max-height: 250px; overflow-y: auto;">
                            ${candlePatterns.map(pattern => `
                                <div class="pattern-entry">
                                    <div class="signal ${pattern.signal.toLowerCase()}">${pattern.type}</div>
                                    <div class="signal-strength">${pattern.strength} Signal</div>
                                    <div class="explanation">${pattern.reason}</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            } else {
                patternsHTML = `
                    <div class="indicator">
                        <h3>${patternTitle}</h3>
                        <div class="explanation">No significant patterns detected in recent data.</div>
                    </div>
                `;
            }

            document.getElementById('indicators').innerHTML = `
                <div class="indicator">
                    <h3>üìà RSI (${rsiPeriod})</h3>
                    <div class="indicator-value">${rsiDisplay}</div>
                    <div class="signal ${rsiSignal.signal.toLowerCase()}">${rsiSignal.signal}</div>
                    <div class="signal-strength">${rsiSignal.strength} Signal</div>
                    <div class="explanation">${rsiSignal.reason}</div>
                    ${currentRSI === null ? `<div style="font-size: 0.8em; color: var(--warning-color); margin-top: 5px;">‚ö†Ô∏è ${rsiStatus}</div>` : ''}
                </div>

                <div class="indicator">
                    <h3>üìä Moving Average (${smaPeriod})</h3>
                    <div class="signal ${smaSignal.signal.toLowerCase()}">${smaSignal.signal}</div>
                    <div class="signal-strength">${smaSignal.strength} Signal</div>
                    <div class="explanation">${smaSignal.reason}</div>
                </div>

                <div class="indicator">
                    <h3>üìè Bollinger Bands (${bbPeriod})</h3>
                    <div class="signal ${bbSignal.signal.toLowerCase()}">${bbSignal.signal}</div>
                    <div class="signal-strength">${bbSignal.strength} Signal</div>
                    <div class="explanation">${bbSignal.reason}</div>
                </div>

                ${patternsHTML}

                <div class="educational-notes">
                    <strong>üìö Educational Notes:</strong><br>
                    ‚Ä¢ <strong>Adaptive Indicators:</strong> Period lengths automatically adjust based on available data (${dataLength} points)<br>
                    ‚Ä¢ <strong>Technical Indicators:</strong> RSI(${rsiPeriod}), SMA(${smaPeriod}), and BB(${bbPeriod}) provide quantitative analysis<br>
                    ‚Ä¢ <strong>Candlestick Patterns:</strong> Visual patterns that reveal market psychology and sentiment<br>
                    ‚Ä¢ <strong>Combined Analysis:</strong> Both technical indicators and candlestick patterns work together for comprehensive market analysis<br>
                    ‚Ä¢ <strong>Pattern Recognition:</strong> Doji = indecision, Hammer = potential reversal, Engulfing = strong momentum<br>
                    ‚Ä¢ <strong>AI Enhancement:</strong> Machine learning analyzes all signals together for improved accuracy
                </div>
            `;
        }

        function displaySummary(overallSignal, totalSignals, coin) {
            const signalClass = overallSignal.signal.toLowerCase();
            const emoji = overallSignal.signal === 'BUY' ? 'üöÄ' : overallSignal.signal === 'SELL' ? 'üìâ' : '‚è∏Ô∏è';

            // Build detailed breakdown if available
            let breakdownHTML = '';
            if (overallSignal.buyCount !== undefined) {
                breakdownHTML = `
                    <div style="margin-top: 10px; font-size: 0.85em; opacity: 0.9;">
                        Signal Breakdown: ${overallSignal.buyCount} BUY ‚Ä¢ ${overallSignal.sellCount} SELL ‚Ä¢ ${overallSignal.neutralCount} NEUTRAL
                        <br>Actionable Signals: ${overallSignal.buyPercentage}% BUY vs ${overallSignal.sellPercentage}% SELL
                    </div>
                `;
            }

            document.getElementById('taSummary').innerHTML = `
                <div class="ta-summary">
                    <h3>üìã Technical Analysis Summary for ${coin}</h3>
                    <div class="overall-signal">${emoji} ${overallSignal.signal}</div>
                    <div class="confidence">Confidence: ${overallSignal.confidence}%</div>
                    <div style="margin-top: 15px; font-size: 0.9em;">
                        Based on ${totalSignals} technical indicators and patterns
                    </div>
                    ${breakdownHTML}
                    <div style="margin-top: 15px; font-size: 0.85em; opacity: 0.9; border-top: 1px solid rgba(255,255,255,0.3); padding-top: 15px;">
                        <strong>‚ö†Ô∏è Remember:</strong> Technical analysis and AI insights are educational tools, not crystal balls. They help identify trends and patterns, but markets can be unpredictable. Technical indicators may start mid-timeframe due to calculation requirements. AI analysis enhances traditional indicators but should not be solely relied upon. This is educational content only, not investment advice. Always do your own research and never invest more than you can afford to lose.
                    </div>
                </div>
            `;
            
            document.getElementById('taSummary').style.display = 'block';
        }

        // =============================================================================
        // AI-POWERED ANALYSIS FUNCTIONS
        // =============================================================================

        // Global variables to store analysis data for AI processing
        let currentAnalysisData = null;

        /**
         * Perform AI-powered market mood analysis
         * Uses Cohere v2/classify endpoint via worker
         */
        async function performAIAnalysis(priceData, rsi, sma20, bb, signals, coinId) {
            try {
                console.log('ü§ñ Starting AI analysis...');
                
                // ‚úÖ FIX: Extract LIVE current price and indicator values from actual chart data
                const liveCurrentPrice = priceData[priceData.length - 1].y;
                const liveCurrentRSI = rsi.length > 0 ? rsi[rsi.length - 1].y : 50;
                const liveCurrentSMA = sma20.length > 0 ? sma20[sma20.length - 1].y : liveCurrentPrice;
                const liveCurrentBBUpper = bb.upper.length > 0 ? bb.upper[bb.upper.length - 1].y : liveCurrentPrice * 1.05;
                const liveCurrentBBLower = bb.lower.length > 0 ? bb.lower[bb.lower.length - 1].y : liveCurrentPrice * 0.95;
                
                const smaSignal = signals.find(s => s.type === 'SMA')?.signal || 'NEUTRAL';
                const bbSignal = signals.find(s => s.type === 'BB')?.signal || 'NEUTRAL';
                
                console.log(`üìä LIVE Analysis Context: Price=$${liveCurrentPrice.toLocaleString()}, RSI=${liveCurrentRSI.toFixed(1)}, SMA=$${liveCurrentSMA.toLocaleString()}, BB=[$${liveCurrentBBLower.toLocaleString()}-$${liveCurrentBBUpper.toLocaleString()}]`);
                
                // Store LIVE data for potential AI explanation later with actual price context
                currentAnalysisData = {
                    priceData, rsi, sma: sma20, bb, signals, coin: coinId, 
                    timeframe: parseInt(document.getElementById('timeframe').value),
                    currentPrice: liveCurrentPrice,
                    currentRSI: liveCurrentRSI,
                    currentSMA: liveCurrentSMA,
                    currentBBUpper: liveCurrentBBUpper,
                    currentBBLower: liveCurrentBBLower
                };
                
                // Call AI analysis endpoint with LIVE values
                const response = await fetch(`${WORKER_URL}/ai-analysis`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        rsi: liveCurrentRSI,
                        smaSignal: smaSignal,
                        bbSignal: bbSignal,
                        priceData: priceData,
                        coin: coinId
                    }),
                });
                
                if (!response.ok) {
                    throw new Error(`AI Analysis API error: ${response.status}`);
                }
                
                const aiResult = await response.json();
                console.log('ü§ñ AI Analysis result:', aiResult);
                
                // Display AI analysis results
                displayAIAnalysis(aiResult);
                
                // Show the AI Explain button
                document.getElementById('aiExplainBtn').style.display = 'inline-flex';
                
            } catch (error) {
                console.error('‚ùå AI Analysis API failed, using enhanced local analysis:', error);
                // Use enhanced local analysis as fallback
                const localResult = performLocalAIAnalysis(liveCurrentRSI, smaSignal, bbSignal, priceData, coinId, []);
                displayAIAnalysis(localResult);
                document.getElementById('aiExplainBtn').style.display = 'inline-flex';
            }
        }



        /**
         * Display AI analysis error
         */
        function displayAIAnalysisError(errorMessage) {
            document.getElementById('aiAnalysisSection').style.display = 'block';
            document.getElementById('aiMoodIcon').textContent = '‚ö†Ô∏è';
            document.getElementById('aiMoodLabel').textContent = 'Analysis Failed';
            document.getElementById('aiMoodLabel').style.color = 'var(--danger-color)';
            document.getElementById('aiConfidence').textContent = 'Error occurred';
            document.getElementById('aiReasoning').textContent = `AI analysis temporarily unavailable: ${errorMessage}. Using traditional indicators instead.`;
            document.getElementById('aiMethodBadge').textContent = 'Fallback';
        }

        /**
         * Enhanced AI analysis that includes candlestick patterns
         * Combines traditional indicators with pattern recognition
         */
        async function performAIAnalysisWithPatterns(priceData, rsi, sma20, bb, traditionalSignals, candlePatterns, coinId) {
            try {
                console.log('ü§ñ Starting enhanced AI analysis with candlestick patterns...');
                
                // Extract current values
                const liveCurrentPrice = priceData[priceData.length - 1].y;
                const liveCurrentRSI = rsi.length > 0 ? rsi[rsi.length - 1].y : 50;
                const liveCurrentSMA = sma20.length > 0 ? sma20[sma20.length - 1].y : liveCurrentPrice;
                const liveCurrentBBUpper = bb.upper.length > 0 ? bb.upper[bb.upper.length - 1].y : liveCurrentPrice * 1.05;
                const liveCurrentBBLower = bb.lower.length > 0 ? bb.lower[bb.lower.length - 1].y : liveCurrentPrice * 0.95;
                
                const smaSignal = traditionalSignals.find(s => s.type === 'SMA')?.signal || 'NEUTRAL';
                const bbSignal = traditionalSignals.find(s => s.type === 'BB')?.signal || 'NEUTRAL';
                
                console.log(`üìä Enhanced Analysis Context: Price=$${liveCurrentPrice.toLocaleString()}, RSI=${liveCurrentRSI.toFixed(1)}, Patterns=${candlePatterns.length}`);
                
                // Store enhanced data for AI explanation
                currentAnalysisData = {
                    priceData, rsi, sma: sma20, bb, 
                    signals: [...traditionalSignals, ...candlePatterns], 
                    candlePatterns,
                    coin: coinId, 
                    timeframe: parseInt(document.getElementById('timeframe').value),
                    currentPrice: liveCurrentPrice,
                    currentRSI: liveCurrentRSI,
                    currentSMA: liveCurrentSMA,
                    currentBBUpper: liveCurrentBBUpper,
                    currentBBLower: liveCurrentBBLower
                };
                
                // Call enhanced AI analysis endpoint
                const response = await fetch(`${WORKER_URL}/ai-analysis-enhanced`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        rsi: liveCurrentRSI,
                        smaSignal: smaSignal,
                        bbSignal: bbSignal,
                        priceData: priceData,
                        candlePatterns: candlePatterns,
                        coin: coinId
                    }),
                });
                
                if (!response.ok) {
                    // Use enhanced local analysis if enhanced endpoint not available
                    console.log('Enhanced AI endpoint not available, using enhanced local analysis...');
                    const localResult = performLocalAIAnalysis(liveCurrentRSI, smaSignal, bbSignal, priceData, coinId, candlePatterns);
                    displayAIAnalysis(localResult);
                    document.getElementById('aiExplainBtn').style.display = 'inline-flex';
                    return;
                }
                
                const aiResult = await response.json();
                console.log('ü§ñ Enhanced AI Analysis result:', aiResult);
                
                // Display enhanced AI analysis results
                displayEnhancedAIAnalysis(aiResult);
                
                // Show the AI Explain button
                document.getElementById('aiExplainBtn').style.display = 'inline-flex';
                
            } catch (error) {
                console.error('‚ùå Enhanced AI Analysis failed, using enhanced local analysis:', error);
                // Use enhanced local analysis with patterns as fallback
                const liveCurrentPrice = priceData[priceData.length - 1].y;
                const liveCurrentRSI = rsi.length > 0 ? rsi[rsi.length - 1].y : 50;
                const localResult = performLocalAIAnalysis(liveCurrentRSI, smaSignal, bbSignal, priceData, coinId, candlePatterns);
                displayAIAnalysis(localResult);
                document.getElementById('aiExplainBtn').style.display = 'inline-flex';
            }
        }

        /**
         * Display enhanced AI analysis results with candlestick pattern context
         */
        function displayEnhancedAIAnalysis(aiResult) {
            // Show the AI analysis section
            document.getElementById('aiAnalysisSection').style.display = 'block';
            
            // Update mood icon and label
            const moodIcons = {
                'bullish': 'üöÄ',
                'bearish': 'üêª',
                'neutral': '‚öñÔ∏è'
            };
            
            const aiMoodLabel = document.getElementById('aiMoodLabel');
            const aiMoodIcon = document.getElementById('aiMoodIcon');
            
            // Set icon and text
            aiMoodIcon.textContent = moodIcons[aiResult.mood] || 'ü§ñ';
            aiMoodLabel.textContent = aiResult.mood.toUpperCase();
            
            // Apply enhanced styling for mood
            aiMoodLabel.className = '';
            aiMoodLabel.classList.add(aiResult.mood);
            
            if (aiResult.mood === 'neutral') {
                aiMoodLabel.style.color = '#ffffff';
                aiMoodLabel.style.background = 'rgba(255,255,255,0.25)';
                aiMoodLabel.style.border = '2px solid rgba(255,255,255,0.4)';
                aiMoodLabel.style.padding = '8px 16px';
                aiMoodLabel.style.borderRadius = '8px';
                aiMoodLabel.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                aiMoodLabel.style.fontWeight = '800';
            } else if (aiResult.mood === 'bullish') {
                aiMoodLabel.style.color = '#4ade80';
                aiMoodLabel.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                aiMoodLabel.style.fontWeight = '800';
            } else if (aiResult.mood === 'bearish') {
                aiMoodLabel.style.color = '#f87171';
                aiMoodLabel.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                aiMoodLabel.style.fontWeight = '800';
            }
            
            // Enhanced confidence styling
            const aiConfidence = document.getElementById('aiConfidence');
            aiConfidence.textContent = `Confidence: ${aiResult.confidence}%`;
            aiConfidence.style.color = '#ffffff';
            aiConfidence.style.fontWeight = '600';
            aiConfidence.style.textShadow = '1px 1px 2px rgba(0,0,0,0.6)';
            
            // Update reasoning with pattern context
            const reasoning = aiResult.reasoning + (aiResult.patterns ? `\n\nCandlestick Patterns: ${aiResult.patterns}` : '');
            document.getElementById('aiReasoning').textContent = reasoning;
            
            // Update method badge
            const methodText = aiResult.method === 'cohere-enhanced-api' ? 'Cohere AI Enhanced' : 
                              aiResult.method === 'cohere-classify-api' ? 'Cohere AI' : 'Rule-based';
            document.getElementById('aiMethodBadge').textContent = methodText;
        }

        /**
         * Generate comprehensive local AI explanation of current market patterns
         */
        function generateLocalAIExplanation(analysisData) {
            console.log('üß† Generating comprehensive local AI explanation...');
            
            if (!analysisData || !analysisData.priceData) {
                return {
                    explanation: 'Unable to generate explanation: Analysis data is incomplete. Please run a fresh analysis.',
                    method: 'error'
                };
            }
            
            const { priceData, rsi, sma, bb, signals, coin, timeframe, currentPrice, currentRSI, currentSMA, currentBBUpper, currentBBLower, candlePatterns } = analysisData;
            
            let explanation = '';
            
            // Market Overview
            explanation += `üìä **COMPREHENSIVE TECHNICAL ANALYSIS EXPLANATION for ${coin.toUpperCase()}**\n\n`;
            explanation += `**Current Market Snapshot:**\n`;
            explanation += `‚Ä¢ Price: $${currentPrice.toLocaleString()}\n`;
            explanation += `‚Ä¢ Timeframe Analyzed: ${timeframe} days\n`;
            explanation += `‚Ä¢ Total Data Points: ${priceData.length}\n\n`;
            
            // RSI Analysis
            explanation += `**üìà RSI Analysis (Relative Strength Index):**\n`;
            if (rsi && rsi.length > 0) {
                explanation += `‚Ä¢ Current RSI: ${currentRSI.toFixed(2)}\n`;
                if (currentRSI < 20) {
                    explanation += `‚Ä¢ **EXTREMELY OVERSOLD**: RSI below 20 suggests the asset is heavily oversold and due for a potential bounce. This is a very strong bullish signal.\n`;
                } else if (currentRSI < 30) {
                    explanation += `‚Ä¢ **OVERSOLD**: RSI below 30 indicates oversold conditions. Historically, this often precedes price recoveries.\n`;
                } else if (currentRSI > 80) {
                    explanation += `‚Ä¢ **EXTREMELY OVERBOUGHT**: RSI above 80 suggests the asset is heavily overbought and may face selling pressure.\n`;
                } else if (currentRSI > 70) {
                    explanation += `‚Ä¢ **OVERBOUGHT**: RSI above 70 indicates overbought conditions. This could signal a potential pullback.\n`;
                } else if (currentRSI >= 45 && currentRSI <= 55) {
                    explanation += `‚Ä¢ **BALANCED**: RSI around 50 shows neutral momentum with no extreme conditions.\n`;
                } else {
                    explanation += `‚Ä¢ **NORMAL RANGE**: RSI is within typical trading range, suggesting balanced market conditions.\n`;
                }
            } else {
                explanation += `‚Ä¢ RSI calculation pending due to limited data points.\n`;
            }
            explanation += '\n';
            
            // Moving Average Analysis
            explanation += `**üìä Moving Average Analysis:**\n`;
            if (sma && sma.length > 0) {
                explanation += `‚Ä¢ Current SMA: $${currentSMA.toLocaleString()}\n`;
                const priceVsSMA = ((currentPrice - currentSMA) / currentSMA) * 100;
                explanation += `‚Ä¢ Price vs SMA: ${priceVsSMA >= 0 ? '+' : ''}${priceVsSMA.toFixed(2)}%\n`;
                
                if (currentPrice > currentSMA * 1.02) {
                    explanation += `‚Ä¢ **BULLISH TREND**: Price is significantly above the moving average, indicating upward momentum.\n`;
                } else if (currentPrice < currentSMA * 0.98) {
                    explanation += `‚Ä¢ **BEARISH TREND**: Price is below the moving average, suggesting downward pressure.\n`;
                } else {
                    explanation += `‚Ä¢ **CONSOLIDATION**: Price is trading near the moving average, indicating potential consolidation phase.\n`;
                }
            } else {
                explanation += `‚Ä¢ Moving average calculation pending due to limited data points.\n`;
            }
            explanation += '\n';
            
            // Bollinger Bands Analysis
            explanation += `**üìè Bollinger Bands Analysis:**\n`;
            if (bb && bb.upper.length > 0) {
                explanation += `‚Ä¢ Upper Band: $${currentBBUpper.toLocaleString()}\n`;
                explanation += `‚Ä¢ Lower Band: $${currentBBLower.toLocaleString()}\n`;
                explanation += `‚Ä¢ Band Width: $${(currentBBUpper - currentBBLower).toLocaleString()}\n`;
                
                if (currentPrice < currentBBLower) {
                    explanation += `‚Ä¢ **OVERSOLD SIGNAL**: Price is below the lower Bollinger Band, suggesting potential oversold conditions and possible reversal.\n`;
                } else if (currentPrice > currentBBUpper) {
                    explanation += `‚Ä¢ **OVERBOUGHT SIGNAL**: Price is above the upper Bollinger Band, indicating potential overbought conditions.\n`;
                } else {
                    const bandPosition = ((currentPrice - currentBBLower) / (currentBBUpper - currentBBLower)) * 100;
                    explanation += `‚Ä¢ **BAND POSITION**: Price is at ${bandPosition.toFixed(1)}% of the band range, indicating ${bandPosition > 50 ? 'upper' : 'lower'} band pressure.\n`;
                }
            } else {
                explanation += `‚Ä¢ Bollinger Bands calculation pending due to limited data points.\n`;
            }
            explanation += '\n';
            
            // Pattern Analysis
            if (candlePatterns && candlePatterns.length > 0) {
                explanation += `**üïØÔ∏è Pattern Recognition:**\n`;
                const bullishPatterns = candlePatterns.filter(p => p.signal === 'BUY');
                const bearishPatterns = candlePatterns.filter(p => p.signal === 'SELL');
                const neutralPatterns = candlePatterns.filter(p => p.signal === 'NEUTRAL');
                
                explanation += `‚Ä¢ **Patterns Detected**: ${candlePatterns.length} total (${bullishPatterns.length} bullish, ${bearishPatterns.length} bearish, ${neutralPatterns.length} neutral)\n`;
                
                if (bullishPatterns.length > 0) {
                    explanation += `‚Ä¢ **Bullish Patterns**: ${bullishPatterns.map(p => p.type).join(', ')}\n`;
                }
                if (bearishPatterns.length > 0) {
                    explanation += `‚Ä¢ **Bearish Patterns**: ${bearishPatterns.map(p => p.type).join(', ')}\n`;
                }
                if (neutralPatterns.length > 0) {
                    explanation += `‚Ä¢ **Neutral Patterns**: ${neutralPatterns.map(p => p.type).join(', ')}\n`;
                }
                explanation += '\n';
            }
            
            // Price Trend Analysis
            if (priceData.length >= 3) {
                explanation += `**üìà Price Trend Analysis:**\n`;
                const recentPrices = priceData.slice(-3);
                const shortTermTrend = ((recentPrices[2].y - recentPrices[0].y) / recentPrices[0].y) * 100;
                
                explanation += `‚Ä¢ **Short-term Trend**: ${shortTermTrend >= 0 ? '+' : ''}${shortTermTrend.toFixed(2)}%\n`;
                
                if (Math.abs(shortTermTrend) > 2) {
                    explanation += `‚Ä¢ **Strong Movement**: ${shortTermTrend > 0 ? 'Significant upward momentum' : 'Significant downward momentum'} detected.\n`;
                } else if (Math.abs(shortTermTrend) > 0.5) {
                    explanation += `‚Ä¢ **Moderate Movement**: ${shortTermTrend > 0 ? 'Mild upward trend' : 'Mild downward trend'} observed.\n`;
                } else {
                    explanation += `‚Ä¢ **Sideways Movement**: Price showing minimal directional change, indicating consolidation.\n`;
                }
                explanation += '\n';
            }
            
            // Signal Summary
            explanation += `**üéØ Signal Summary:**\n`;
            if (signals && signals.length > 0) {
                const buySignals = signals.filter(s => s.signal === 'BUY');
                const sellSignals = signals.filter(s => s.signal === 'SELL');
                const neutralSignals = signals.filter(s => s.signal === 'NEUTRAL');
                
                explanation += `‚Ä¢ **Buy Signals**: ${buySignals.length} (${buySignals.map(s => s.type).join(', ')})\n`;
                explanation += `‚Ä¢ **Sell Signals**: ${sellSignals.length} (${sellSignals.map(s => s.type).join(', ')})\n`;
                explanation += `‚Ä¢ **Neutral Signals**: ${neutralSignals.length} (${neutralSignals.map(s => s.type).join(', ')})\n`;
            }
            explanation += '\n';
            
            // Trading Implications
            explanation += `**üí° Trading Implications:**\n`;
            if (currentRSI < 30 && currentPrice < currentBBLower) {
                explanation += `‚Ä¢ **Strong Buy Setup**: Both RSI and Bollinger Bands suggest oversold conditions.\n`;
            } else if (currentRSI > 70 && currentPrice > currentBBUpper) {
                explanation += `‚Ä¢ **Strong Sell Setup**: Both RSI and Bollinger Bands suggest overbought conditions.\n`;
            } else {
                explanation += `‚Ä¢ **Mixed Signals**: Indicators show conflicting signals, suggesting caution and further analysis.\n`;
            }
            
            explanation += `‚Ä¢ **Risk Management**: Always use stop-losses and position sizing appropriate for your risk tolerance.\n`;
            explanation += `‚Ä¢ **Confirmation**: Look for additional confirmations before making trading decisions.\n\n`;
            
            // Educational Note
            explanation += `**üìö Educational Note:**\n`;
            explanation += `This analysis uses adaptive technical indicators that adjust to available data. `;
            explanation += `Short timeframes may have fewer data points, affecting indicator reliability. `;
            explanation += `Always combine technical analysis with fundamental analysis and risk management. `;
            explanation += `Past performance does not guarantee future results.\n\n`;
            
            explanation += `**‚ö†Ô∏è Disclaimer**: This is educational content only, not financial advice. Always do your own research and consult with financial professionals before making investment decisions.`;
            
            return {
                explanation: explanation,
                method: 'comprehensive-local-analysis',
                timestamp: new Date().toISOString()
            };
        }

        /**
         * Get AI explanation of current pattern
         * Uses local comprehensive analysis with API fallback
         */
        async function getAIExplanation() {
            if (!currentAnalysisData) {
                alert('Please run an analysis first!');
                return;
            }
            
            try {
                console.log('üß† Generating AI explanation...');
                
                // Show loading state
                document.getElementById('aiExplanationSection').style.display = 'block';
                document.getElementById('aiExplanationContent').innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px; color: var(--text-secondary);">
                        <div class="loading-spinner"></div>
                        Generating comprehensive AI explanation...
                    </div>
                `;
                
                // ‚úÖ FIX: Extract LIVE values from current chart data for most accurate AI explanation
                const latestPriceData = currentAnalysisData.priceData;
                const latestRSIData = currentAnalysisData.rsi;
                const latestSMAData = currentAnalysisData.sma;
                const latestBBData = currentAnalysisData.bb;
                
                // Get the actual LATEST values from the arrays (what's shown on chart)
                const liveCurrentPrice = latestPriceData[latestPriceData.length - 1].y;
                const liveCurrentRSI = latestRSIData.length > 0 ? latestRSIData[latestRSIData.length - 1].y : 50;
                const liveCurrentSMA = latestSMAData.length > 0 ? latestSMAData[latestSMAData.length - 1].y : liveCurrentPrice;
                const liveCurrentBBUpper = latestBBData.upper.length > 0 ? latestBBData.upper[latestBBData.upper.length - 1].y : liveCurrentPrice * 1.05;
                const liveCurrentBBLower = latestBBData.lower.length > 0 ? latestBBData.lower[latestBBData.lower.length - 1].y : liveCurrentPrice * 0.95;
                
                console.log(`üìä LIVE Chart Values - Price: $${liveCurrentPrice.toLocaleString()}, RSI: ${liveCurrentRSI.toFixed(1)}, SMA: $${liveCurrentSMA.toLocaleString()}, BB: [$${liveCurrentBBLower.toLocaleString()}-$${liveCurrentBBUpper.toLocaleString()}]`);
                
                // Prepare comprehensive data for analysis
                const comprehensiveData = {
                    ...currentAnalysisData,
                    currentPrice: liveCurrentPrice,
                    currentRSI: liveCurrentRSI,
                    currentSMA: liveCurrentSMA,
                    currentBBUpper: liveCurrentBBUpper,
                    currentBBLower: liveCurrentBBLower
                };
                
                // Try API first, then use local comprehensive analysis as fallback
                try {
                    const explanationData = {
                        rsi: currentAnalysisData.rsi,
                        sma: currentAnalysisData.sma,
                        bb: currentAnalysisData.bb,
                        signals: currentAnalysisData.signals,
                        coin: currentAnalysisData.coin,
                        timeframe: currentAnalysisData.timeframe,
                        priceData: currentAnalysisData.priceData,
                        currentPrice: liveCurrentPrice,
                        currentRSI: liveCurrentRSI,
                        currentSMA: liveCurrentSMA,
                        currentBBUpper: liveCurrentBBUpper,
                        currentBBLower: liveCurrentBBLower
                    };
                    
                    const response = await fetch(`${WORKER_URL}/ai-explain`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(explanationData),
                    });
                    
                    if (response.ok) {
                        const aiExplanation = await response.json();
                        console.log('üß† AI API Explanation result:', aiExplanation);
                        displayAIExplanation(aiExplanation);
                        return;
                    } else {
                        throw new Error(`API error: ${response.status}`);
                    }
                } catch (apiError) {
                    console.log('üß† AI API not available, using comprehensive local analysis:', apiError.message);
                    
                    // Use comprehensive local analysis
                    const localExplanation = generateLocalAIExplanation(comprehensiveData);
                    console.log('üß† Local Explanation generated:', localExplanation);
                    displayAIExplanation(localExplanation);
                }
                
            } catch (error) {
                console.error('‚ùå AI Explanation completely failed:', error);
                displayAIExplanationError(error.message);
            }
        }

        /**
         * Display AI explanation results
         */
        function displayAIExplanation(aiExplanation) {
            // Format the explanation with proper line breaks and markdown-style formatting
            let formattedExplanation = aiExplanation.explanation
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Bold text
                .replace(/\n\n/g, '</p><p>') // Paragraph breaks
                .replace(/\n/g, '<br>') // Line breaks
                .replace(/‚Ä¢/g, '&bull;'); // Bullet points
            
            document.getElementById('aiExplanationContent').innerHTML = `<div style="line-height: 1.6;">${formattedExplanation}</div>`;
            
            // Update method badge with better descriptions
            let methodText;
            switch (aiExplanation.method) {
                case 'cohere-chat-api':
                    methodText = 'Cohere AI';
                    break;
                case 'comprehensive-local-analysis':
                    methodText = 'AI-Enhanced Local';
                    break;
                case 'rule-based':
                    methodText = 'Rule-based';
                    break;
                case 'error':
                    methodText = 'Error';
                    break;
                default:
                    methodText = 'Local Analysis';
            }
            document.getElementById('explainMethodBadge').textContent = methodText;
            
            console.log('‚úÖ AI explanation displayed successfully with method:', methodText);
        }

        /**
         * Display AI explanation error
         */
        function displayAIExplanationError(errorMessage) {
            document.getElementById('aiExplanationContent').innerHTML = `
                <div style="color: var(--danger-color);">
                    <strong>‚ö†Ô∏è AI Explanation Failed:</strong><br>
                    ${errorMessage}<br><br>
                    <em>Try again in a moment or refer to the technical indicators above for manual analysis.</em>
                </div>
            `;
            document.getElementById('explainMethodBadge').textContent = 'Error';
        }

        // Add CSS animation for loading spinner and mobile optimizations
        const style = document.createElement('style');
        style.textContent = `
            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }
            
            @keyframes fadeIn {
                0% { opacity: 0; transform: translateY(10px); }
                100% { opacity: 1; transform: translateY(0); }
            }
            
            .loading-spinner {
                width: 20px;
                height: 20px;
                border: 2px solid var(--border-color);
                border-top: 2px solid var(--accent-color);
                border-radius: 50%;
                animation: spin 1s linear infinite;
            }
            
            /* üõ†Ô∏è FIX: Mobile-specific AI section improvements with enhanced theme support */
            @media (max-width: 768px) {
                #aiAnalysisSection > div > div {
                    grid-template-columns: 1fr !important;
                }
                
                #aiExplainBtn {
                    width: 100% !important;
                    margin-bottom: 5px;
                }
                
                /* Smooth animations for mobile */
                .indicator {
                    animation: fadeIn 0.3s ease-out;
                }
                
                /* Better chart container on mobile */
                .chart-container h3 {
                    font-size: 1.1em;
                    margin-bottom: 10px;
                }
                
                /* Improved loading state with better contrast */
                .loading {
                    padding: 20px;
                    font-size: 0.9em;
                    color: var(--text-primary);
                    background: var(--bg-secondary);
                    border-radius: 8px;
                    border: 1px solid var(--border-color);
                }
                
                /* Enhanced error state for mobile */
                .error {
                    font-size: 0.85em;
                    padding: 1rem;
                    border-radius: 8px;
                }
            }
            
            /* Accessibility improvements */
            @media (prefers-reduced-motion: reduce) {
                .loading-spinner {
                    animation: none !important;
                }
                * {
                    animation-duration: 0.01ms !important;
                    animation-iteration-count: 1 !important;
                    transition-duration: 0.01ms !important;
                }
            }
        `;
        document.head.appendChild(style);

        // =============================================================================
        // ENHANCED ANALYSIS FUNCTION WITH AI INTEGRATION
        // =============================================================================

        // Enhanced analyzeTA function that includes AI analysis
        async function analyzeTA() {
            const coinId = document.getElementById('coinSelect').value;
            const timeframe = parseInt(document.getElementById('timeframe').value);
            
            // üîß FIXED: Destroy test chart if it exists
            if (window.testChartInstance) {
                // Unregister test chart from responsive manager
                if (window.taChartManager) {
                    window.taChartManager.unregisterChart('taChart');
                }
                window.testChartInstance.destroy();
                window.testChartInstance = null;
                console.log('üß™ Test chart destroyed, starting real analysis...');
            }
            
            // ‚úÖ SCROLL FIX: Prevent any automatic scrolling during analysis
            const currentScrollPosition = window.pageYOffset;
            
            // Show loading states for both charts
            document.getElementById('loading').style.display = 'block';
            document.getElementById('candleLoading').style.display = 'block';
            document.getElementById('taChart').style.display = 'none';
            document.getElementById('candleChart').style.display = 'none';
            document.getElementById('indicators').innerHTML = '<div class="loading">Calculating indicators...</div>';
            document.getElementById('taSummary').style.display = 'none';
            // Hide AI sections initially
            document.getElementById('aiAnalysisSection').style.display = 'none';
            document.getElementById('aiExplainBtn').style.display = 'none';
            document.getElementById('chartError').style.display = 'none';
            document.getElementById('candleError').style.display = 'none';

            try {
                console.log(`Starting analysis for ${coinId} over ${timeframe} days`);
                
                // Fetch both price data and OHLC data in parallel
                const [priceData, ohlcData] = await Promise.all([
                    fetchPriceData(coinId, timeframe),
                    fetchOHLCData(coinId, timeframe)
                ]);
                
                // Calculate indicators with adaptive periods based on available data
                console.log('Calculating adaptive technical indicators...');
                
                // Determine appropriate periods based on data length
                const dataLength = priceData.length;
                const smaPeriod = Math.min(Math.max(Math.floor(dataLength * 0.7), 3), 20); // Use 70% of data or minimum 3, max 20
                const rsiPeriod = Math.min(Math.max(Math.floor(dataLength * 0.5), 3), 14); // Use 50% of data or minimum 3, max 14
                const bbPeriod = smaPeriod; // Use same period as SMA
                
                console.log(`üìä Adaptive periods: SMA=${smaPeriod}, RSI=${rsiPeriod}, BB=${bbPeriod} (based on ${dataLength} data points)`);
                
                const sma20 = calculateSMA(priceData, smaPeriod);
                const rsi = calculateRSI(priceData, rsiPeriod);
                const bb = calculateBollingerBands(priceData, bbPeriod);
                
                // Analyze candlestick patterns (use price data if no OHLC)
                console.log('Analyzing candlestick patterns...');
                const candlePatterns = ohlcData.length > 0 ? 
                    analyzeCandlestickPatterns(ohlcData) : 
                    analyzePriceMovementPatterns(priceData);
                
                console.log('Indicators calculated:', {
                    pricePoints: priceData.length,
                    ohlcPoints: ohlcData.length,
                    smaPoints: sma20.length,
                    rsiPoints: rsi.length,
                    bbPoints: bb.upper.length,
                    candlePatterns: candlePatterns.length
                });
                
                // Generate signals (including candlestick patterns)
                const traditionalSignals = generateTradingSignals(priceData, rsi, sma20, bb);
                const allSignals = [...traditionalSignals, ...candlePatterns];
                const overallSignal = calculateOverallSignal(allSignals);
                
                // Display both charts
                console.log('Creating charts...');
                displayChart(priceData, sma20, bb, smaPeriod);
                
                // Always display OHLC section, create fallback if needed
                if (ohlcData && ohlcData.length > 0) {
                    displayCandlestickChart(ohlcData, coinId);
                } else {
                    console.warn('No valid OHLC data available, creating price-based visualization...');
                    // Create simple price-based OHLC visualization
                    displayPriceBasedOHLC(priceData, coinId);
                }
                
                // Update indicators display to include candlestick patterns
                displayIndicatorsWithPatterns(rsi, sma20, traditionalSignals, candlePatterns, smaPeriod, rsiPeriod, bbPeriod, dataLength);
                displaySummary(overallSignal, allSignals.length, coinId.toUpperCase());
                
                // Final backup check to ensure charts are visible
                setTimeout(() => {
                    const canvas = document.getElementById('taChart');
                    const candleCanvas = document.getElementById('candleChart');
                    
                    if (canvas && chartInstance && (canvas.clientWidth === 0 || canvas.clientHeight === 0 || canvas.style.display === 'none')) {
                        console.log('üîß Chart not visible, attempting backup display...');
                        forceChartDisplay();
                    }
                    
                    if (candleCanvas && candleChartInstance && (candleCanvas.clientWidth === 0 || candleCanvas.clientHeight === 0 || candleCanvas.style.display === 'none')) {
                        console.log('üîß Candlestick chart not visible, forcing display...');
                        candleCanvas.style.display = 'block';
                        candleCanvas.style.visibility = 'visible';
                        candleCanvas.classList.add('visible');
                        candleChartInstance.update();
                        candleChartInstance.resize();
                    }
                }, 500);
                
                // ü§ñ PERFORM AI ANALYSIS (enhanced with candlestick patterns)
                console.log('ü§ñ Starting AI integration with candlestick patterns...');
                await performAIAnalysisWithPatterns(priceData, rsi, sma20, bb, traditionalSignals, candlePatterns, coinId);
                
                document.getElementById('loading').style.display = 'none';
                document.getElementById('candleLoading').style.display = 'none';
                console.log('Analysis complete!');
                
                // Chart analysis complete
                console.log('‚úÖ Technical analysis complete with both charts displayed!');
                
                // ‚úÖ SCROLL FIX: Restore scroll position to prevent unwanted scrolling
                window.scrollTo(0, currentScrollPosition);
                
            } catch (error) {
                console.error('Analysis error:', error);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('candleLoading').style.display = 'none';
                document.getElementById('chartError').style.display = 'block';
                document.getElementById('candleError').style.display = 'block';
                document.getElementById('chartError').innerHTML = `<strong>‚ö†Ô∏è Analysis Failed:</strong> ${error.message}. Please try a longer timeframe or check your connection.`;
                document.getElementById('candleError').innerHTML = `<strong>‚ö†Ô∏è Candlestick Chart Failed:</strong> ${error.message}`;
                document.getElementById('indicators').innerHTML = '<div class="error">Analysis failed - please try again with a longer timeframe</div>';
                // ‚úÖ SCROLL FIX: Restore scroll position even on error
                window.scrollTo(0, currentScrollPosition);
            }
        }

        // Theme toggle functionality
        function handleThemeToggle() {
            document.body.classList.toggle('dark-theme');
            const isDark = document.body.classList.contains('dark-theme');
            
            document.getElementById('themeToggle').textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
            
            // Save theme preference
            localStorage.setItem('cryptoDashboardTheme', isDark ? 'dark' : 'light');
        }

        // üîß FIXED: Test chart functionality
        function testChart() {
            const canvas = document.getElementById('taChart');
            const ctx = canvas.getContext('2d');
            
            // Simple test chart to verify Chart.js is working
            const testChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: ['Day 1', 'Day 2', 'Day 3', 'Day 4', 'Day 5'],
                    datasets: [{
                        label: 'Test Data',
                        data: [100, 150, 120, 180, 160],
                        borderColor: '#3B82F6',
                        backgroundColor: '#3B82F620',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'üìä Chart Test - Click Analyze to Load Real Data',
                            font: { size: 18, weight: 'bold' }
                        }
                    }
                }
            });
            
            // Show test chart
            canvas.style.display = 'block';
            canvas.style.visibility = 'visible';
            canvas.classList.add('visible');
            
            return testChart;
        }

        // Enhanced Responsive Chart Management for TA Module
        class TAResponsiveChartManager {
            constructor() {
                this.charts = new Map();
                this.resizeTimeout = null;
                this.orientationTimeout = null;
                this.isInitialized = false;
            }
            
            registerChart(chartId, chartInstance) {
                this.charts.set(chartId, chartInstance);
                console.log(`üìä Registered chart: ${chartId}`);
            }
            
            unregisterChart(chartId) {
                if (this.charts.has(chartId)) {
                    this.charts.delete(chartId);
                    console.log(`üóëÔ∏è Unregistered chart: ${chartId}`);
                }
            }
            
            resizeAllCharts() {
                console.log('üîÑ Resizing all TA charts...');
                let resizedCount = 0;
                
                this.charts.forEach((chart, chartId) => {
                    try {
                        if (chart && typeof chart.resize === 'function') {
                            // Ensure container is visible before resizing
                            const canvas = document.getElementById(chartId);
                            const container = canvas?.closest('.ta-responsive-chart-container');
                            
                            if (container && this.isContainerVisible(container)) {
                                chart.resize();
                                chart.update('none'); // Update without animation for better performance
                                resizedCount++;
                                console.log(`‚úÖ Resized chart: ${chartId}`);
                            }
                        }
                    } catch (error) {
                        console.error(`‚ùå Error resizing chart ${chartId}:`, error);
                    }
                });
                
                console.log(`üìä Resized ${resizedCount} charts successfully`);
            }
            
            isContainerVisible(container) {
                const rect = container.getBoundingClientRect();
                return rect.width > 0 && rect.height > 0;
            }
            
            handleResize() {
                clearTimeout(this.resizeTimeout);
                this.resizeTimeout = setTimeout(() => {
                    this.resizeAllCharts();
                    
                    // Additional mobile optimizations
                    if (window.innerWidth <= 768) {
                        this.optimizeForMobile();
                    }
                }, 200);
            }
            
            handleOrientationChange() {
                clearTimeout(this.orientationTimeout);
                this.orientationTimeout = setTimeout(() => {
                    console.log('üì± Orientation changed, optimizing charts...');
                    this.resizeAllCharts();
                    
                    // Force re-render after orientation change
                    this.charts.forEach((chart, chartId) => {
                        try {
                            if (chart && typeof chart.render === 'function') {
                                chart.render();
                            }
                        } catch (error) {
                            console.error(`‚ùå Error re-rendering chart ${chartId} after orientation change:`, error);
                        }
                    });
                }, 500);
            }
            
            optimizeForMobile() {
                console.log('üì± Applying mobile optimizations...');
                
                // Ensure chart containers have proper mobile classes
                document.querySelectorAll('.ta-responsive-chart-container').forEach(container => {
                    if (!container.classList.contains('mobile-optimized')) {
                        container.classList.add('mobile-optimized');
                        container.style.width = '100%';
                        container.style.maxWidth = '100%';
                        container.style.boxSizing = 'border-box';
                    }
                });
                
                // Ensure chart wrappers are properly sized
                document.querySelectorAll('.ta-responsive-chart-wrapper').forEach(wrapper => {
                    wrapper.style.width = '100%';
                    wrapper.style.maxWidth = 'calc(100vw - 1rem)';
                    wrapper.style.overflow = 'visible';
                });
            }
            
            initialize() {
                if (this.isInitialized) return;
                
                console.log('üöÄ Initializing TA Responsive Chart Manager...');
                
                // Add resize listener
                window.addEventListener('resize', () => this.handleResize());
                
                // Add orientation change listener
                window.addEventListener('orientationchange', () => this.handleOrientationChange());
                
                // Initial mobile optimization if needed
                if (window.innerWidth <= 768) {
                    setTimeout(() => this.optimizeForMobile(), 100);
                }
                
                this.isInitialized = true;
                console.log('‚úÖ TA Responsive Chart Manager initialized');
            }
            
            destroy() {
                clearTimeout(this.resizeTimeout);
                clearTimeout(this.orientationTimeout);
                this.charts.clear();
                this.isInitialized = false;
            }
        }
        
        // Create global instance
        window.taChartManager = new TAResponsiveChartManager();
        
        // Initialize theme and Bitcoin analysis
        window.onload = function() {
            // Load theme preference
            const savedTheme = localStorage.getItem('cryptoDashboardTheme');
            if (savedTheme === 'dark') {
                document.body.classList.add('dark-theme');
                document.getElementById('themeToggle').textContent = '‚òÄÔ∏è';
            }
            
            // Set up theme toggle event listener
            document.getElementById('themeToggle').addEventListener('click', handleThemeToggle);
            
            // Initialize responsive chart manager
            window.taChartManager.initialize();
            
            // üîß FIXED: Show test chart to verify Chart.js is working
            setTimeout(() => {
                const testChartInstance = testChart();
                console.log('üß™ Test chart displayed - Chart.js is working!');
                
                // Store reference to destroy when real analysis runs
                window.testChartInstance = testChartInstance;
                
                // Register test chart for responsive handling
                if (testChartInstance) {
                    window.taChartManager.registerChart('taChart', testChartInstance);
                }
            }, 100);
            
            // You can uncomment the line below to auto-analyze Bitcoin on page load
            // analyzeTA();
        };
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (window.taChartManager) {
                window.taChartManager.destroy();
                console.log('üßπ TA Chart Manager cleaned up on page unload');
            }
        });

        /**
         * Local rule-based AI analysis with improved logic
         * More accurate than the basic worker fallback
         */
        function performLocalAIAnalysis(rsi, smaSignal, bbSignal, priceData, coinId, patterns) {
            console.log('ü§ñ Performing enhanced local AI analysis...');
            
            let bullishScore = 0;
            let bearishScore = 0;
            let confidence = 50;
            let reasoning = '';
            
            // Enhanced RSI scoring with extreme conditions
            if (rsi < 20) {
                bullishScore += 3; // Extremely oversold - very bullish
                reasoning += `Extremely oversold RSI (${rsi.toFixed(1)}) suggests strong buying opportunity. `;
            } else if (rsi < 30) {
                bullishScore += 2.5; // Oversold - bullish
                reasoning += `Oversold RSI (${rsi.toFixed(1)}) indicates potential upward reversal. `;
            } else if (rsi > 80) {
                bearishScore += 3; // Extremely overbought - very bearish
                reasoning += `Extremely overbought RSI (${rsi.toFixed(1)}) suggests strong selling pressure. `;
            } else if (rsi > 70) {
                bearishScore += 2.5; // Overbought - bearish
                reasoning += `Overbought RSI (${rsi.toFixed(1)}) indicates potential downward reversal. `;
            } else if (rsi >= 45 && rsi <= 55) {
                bullishScore += 0.5; // Neutral momentum
                reasoning += `Neutral RSI (${rsi.toFixed(1)}) suggests balanced momentum. `;
            }
            
            // SMA scoring
            if (smaSignal === 'BUY') {
                bullishScore += 1.5;
                reasoning += 'Price above moving average supports uptrend. ';
            } else if (smaSignal === 'SELL') {
                bearishScore += 1.5;
                reasoning += 'Price below moving average indicates downtrend. ';
            }
            
            // Bollinger Bands scoring
            if (bbSignal === 'BUY') {
                bullishScore += 1;
                reasoning += 'Price near lower Bollinger Band suggests oversold condition. ';
            } else if (bbSignal === 'SELL') {
                bearishScore += 1;
                reasoning += 'Price near upper Bollinger Band suggests overbought condition. ';
            }
            
            // Price trend analysis
            if (priceData.length >= 3) {
                const recentPrices = priceData.slice(-3);
                const trend = (recentPrices[2].y - recentPrices[0].y) / recentPrices[0].y;
                if (trend > 0.02) {
                    bullishScore += 1.5;
                    reasoning += `Strong upward price trend (+${(trend * 100).toFixed(1)}%). `;
                } else if (trend > 0.005) {
                    bullishScore += 0.5;
                    reasoning += `Mild upward price trend (+${(trend * 100).toFixed(1)}%). `;
                } else if (trend < -0.02) {
                    bearishScore += 1.5;
                    reasoning += `Strong downward price trend (${(trend * 100).toFixed(1)}%). `;
                } else if (trend < -0.005) {
                    bearishScore += 0.5;
                    reasoning += `Mild downward price trend (${(trend * 100).toFixed(1)}%). `;
                }
            }
            
            // Pattern analysis boost
            if (patterns && patterns.length > 0) {
                const bullishPatterns = patterns.filter(p => p.signal === 'BUY').length;
                const bearishPatterns = patterns.filter(p => p.signal === 'SELL').length;
                bullishScore += bullishPatterns * 0.5;
                bearishScore += bearishPatterns * 0.5;
                reasoning += `${bullishPatterns} bullish and ${bearishPatterns} bearish patterns detected. `;
            }
            
            // Determine mood with improved thresholds
            let mood;
            if (bullishScore > bearishScore + 0.5) { // Reduced threshold for more sensitivity
                mood = 'bullish';
                confidence = Math.min(95, 55 + (bullishScore - bearishScore) * 12);
            } else if (bearishScore > bullishScore + 0.5) {
                mood = 'bearish';
                confidence = Math.min(95, 55 + (bearishScore - bullishScore) * 12);
            } else {
                mood = 'neutral';
                confidence = 45 + Math.abs(bullishScore - bearishScore) * 8;
            }
            
            const result = {
                mood: mood,
                confidence: Math.round(confidence),
                reasoning: reasoning.trim() || `Balanced analysis: ${bullishScore.toFixed(1)} bullish vs ${bearishScore.toFixed(1)} bearish signals`,
                method: 'enhanced-local-analysis',
                bullishScore: bullishScore.toFixed(1),
                bearishScore: bearishScore.toFixed(1),
                coin: coinId,
                timestamp: new Date().toISOString()
            };
            
            console.log('ü§ñ Enhanced Local AI Analysis:', result);
            return result;
        }

        /**
         * Display AI analysis results in the UI
         */
        function displayAIAnalysis(aiResult) {
            // Show the AI analysis section
            document.getElementById('aiAnalysisSection').style.display = 'block';
            
            // Update mood icon and label
            const moodIcons = {
                'bullish': 'üöÄ',
                'bearish': 'üêª',
                'neutral': '‚öñÔ∏è'
            };
            
            const aiMoodLabel = document.getElementById('aiMoodLabel');
            const aiMoodIcon = document.getElementById('aiMoodIcon');
            
            // Set icon and text
            aiMoodIcon.textContent = moodIcons[aiResult.mood] || 'ü§ñ';
            aiMoodLabel.textContent = aiResult.mood.toUpperCase();
            
            // ‚úÖ FIX: Apply proper styling classes for better contrast
            aiMoodLabel.className = ''; // Clear existing classes
            aiMoodLabel.classList.add(aiResult.mood); // Add mood-specific class
            
            // Enhanced contrast for different moods
            if (aiResult.mood === 'neutral') {
                // White text with dark background for better contrast on purple
                aiMoodLabel.style.color = '#ffffff';
                aiMoodLabel.style.background = 'rgba(255,255,255,0.25)';
                aiMoodLabel.style.border = '2px solid rgba(255,255,255,0.4)';
                aiMoodLabel.style.padding = '8px 16px';
                aiMoodLabel.style.borderRadius = '8px';
                aiMoodLabel.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                aiMoodLabel.style.fontWeight = '800';
            } else if (aiResult.mood === 'bullish') {
                aiMoodLabel.style.color = '#4ade80';
                aiMoodLabel.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                aiMoodLabel.style.fontWeight = '800';
            } else if (aiResult.mood === 'bearish') {
                aiMoodLabel.style.color = '#f87171';
                aiMoodLabel.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                aiMoodLabel.style.fontWeight = '800';
            }
            
            // Enhanced confidence styling
            const aiConfidence = document.getElementById('aiConfidence');
            aiConfidence.textContent = `Confidence: ${aiResult.confidence}%`;
            aiConfidence.style.color = '#ffffff';
            aiConfidence.style.fontWeight = '600';
            aiConfidence.style.textShadow = '1px 1px 2px rgba(0,0,0,0.6)';
            
            // Update reasoning
            document.getElementById('aiReasoning').textContent = aiResult.reasoning;
            
            // Update method badge
            const methodText = aiResult.method === 'cohere-classify-api' ? 'Cohere AI' : 
                              aiResult.method === 'enhanced-local-analysis' ? 'Enhanced Local' : 'Rule-based';
            document.getElementById('aiMethodBadge').textContent = methodText;
        }
    </script>
</body>
</html> 